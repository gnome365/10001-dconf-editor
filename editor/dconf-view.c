/* dconf-view.c generated by valac 0.38.2.7-b777e, the Vala compiler
 * generated from dconf-view.vala, do not modify */

/*
  This file is part of Dconf Editor

  Dconf Editor is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  Dconf Editor is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with Dconf Editor.  If not, see <http://www.gnu.org/licenses/>.
*/

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>
#include <float.h>
#include <math.h>
#include <glib/gi18n-lib.h>


#define TYPE_KEY_EDITOR_CHILD (key_editor_child_get_type ())
#define KEY_EDITOR_CHILD(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_KEY_EDITOR_CHILD, KeyEditorChild))
#define IS_KEY_EDITOR_CHILD(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_KEY_EDITOR_CHILD))
#define KEY_EDITOR_CHILD_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_KEY_EDITOR_CHILD, KeyEditorChildIface))

typedef struct _KeyEditorChild KeyEditorChild;
typedef struct _KeyEditorChildIface KeyEditorChildIface;
enum  {
	KEY_EDITOR_CHILD_VALUE_HAS_CHANGED_SIGNAL,
	KEY_EDITOR_CHILD_CHILD_ACTIVATED_SIGNAL,
	KEY_EDITOR_CHILD_NUM_SIGNALS
};
static guint key_editor_child_signals[KEY_EDITOR_CHILD_NUM_SIGNALS] = {0};

#define TYPE_KEY_EDITOR_CHILD_SINGLE (key_editor_child_single_get_type ())
#define KEY_EDITOR_CHILD_SINGLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_KEY_EDITOR_CHILD_SINGLE, KeyEditorChildSingle))
#define KEY_EDITOR_CHILD_SINGLE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_KEY_EDITOR_CHILD_SINGLE, KeyEditorChildSingleClass))
#define IS_KEY_EDITOR_CHILD_SINGLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_KEY_EDITOR_CHILD_SINGLE))
#define IS_KEY_EDITOR_CHILD_SINGLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_KEY_EDITOR_CHILD_SINGLE))
#define KEY_EDITOR_CHILD_SINGLE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_KEY_EDITOR_CHILD_SINGLE, KeyEditorChildSingleClass))

typedef struct _KeyEditorChildSingle KeyEditorChildSingle;
typedef struct _KeyEditorChildSingleClass KeyEditorChildSingleClass;
typedef struct _KeyEditorChildSinglePrivate KeyEditorChildSinglePrivate;
enum  {
	KEY_EDITOR_CHILD_SINGLE_0_PROPERTY,
	KEY_EDITOR_CHILD_SINGLE_NUM_PROPERTIES
};
static GParamSpec* key_editor_child_single_properties[KEY_EDITOR_CHILD_SINGLE_NUM_PROPERTIES];
#define _g_variant_unref0(var) ((var == NULL) ? NULL : (var = (g_variant_unref (var), NULL)))

#define TYPE_KEY_EDITOR_CHILD_ENUM (key_editor_child_enum_get_type ())
#define KEY_EDITOR_CHILD_ENUM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_KEY_EDITOR_CHILD_ENUM, KeyEditorChildEnum))
#define KEY_EDITOR_CHILD_ENUM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_KEY_EDITOR_CHILD_ENUM, KeyEditorChildEnumClass))
#define IS_KEY_EDITOR_CHILD_ENUM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_KEY_EDITOR_CHILD_ENUM))
#define IS_KEY_EDITOR_CHILD_ENUM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_KEY_EDITOR_CHILD_ENUM))
#define KEY_EDITOR_CHILD_ENUM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_KEY_EDITOR_CHILD_ENUM, KeyEditorChildEnumClass))

typedef struct _KeyEditorChildEnum KeyEditorChildEnum;
typedef struct _KeyEditorChildEnumClass KeyEditorChildEnumClass;
typedef struct _KeyEditorChildEnumPrivate KeyEditorChildEnumPrivate;
enum  {
	KEY_EDITOR_CHILD_ENUM_0_PROPERTY,
	KEY_EDITOR_CHILD_ENUM_NUM_PROPERTIES
};
static GParamSpec* key_editor_child_enum_properties[KEY_EDITOR_CHILD_ENUM_NUM_PROPERTIES];
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define TYPE_SETTING_OBJECT (setting_object_get_type ())
#define SETTING_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SETTING_OBJECT, SettingObject))
#define SETTING_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SETTING_OBJECT, SettingObjectClass))
#define IS_SETTING_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SETTING_OBJECT))
#define IS_SETTING_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SETTING_OBJECT))
#define SETTING_OBJECT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SETTING_OBJECT, SettingObjectClass))

typedef struct _SettingObject SettingObject;
typedef struct _SettingObjectClass SettingObjectClass;

#define TYPE_KEY (key_get_type ())
#define KEY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_KEY, Key))
#define KEY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_KEY, KeyClass))
#define IS_KEY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_KEY))
#define IS_KEY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_KEY))
#define KEY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_KEY, KeyClass))

typedef struct _Key Key;
typedef struct _KeyClass KeyClass;

#define TYPE_CONTEXT_POPOVER (context_popover_get_type ())
#define CONTEXT_POPOVER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CONTEXT_POPOVER, ContextPopover))
#define CONTEXT_POPOVER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CONTEXT_POPOVER, ContextPopoverClass))
#define IS_CONTEXT_POPOVER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CONTEXT_POPOVER))
#define IS_CONTEXT_POPOVER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CONTEXT_POPOVER))
#define CONTEXT_POPOVER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CONTEXT_POPOVER, ContextPopoverClass))

typedef struct _ContextPopover ContextPopover;
typedef struct _ContextPopoverClass ContextPopoverClass;
typedef struct _Block4Data Block4Data;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_variant_type_free0(var) ((var == NULL) ? NULL : (var = (g_variant_type_free (var), NULL)))

#define TYPE_KEY_EDITOR_CHILD_FLAGS (key_editor_child_flags_get_type ())
#define KEY_EDITOR_CHILD_FLAGS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_KEY_EDITOR_CHILD_FLAGS, KeyEditorChildFlags))
#define KEY_EDITOR_CHILD_FLAGS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_KEY_EDITOR_CHILD_FLAGS, KeyEditorChildFlagsClass))
#define IS_KEY_EDITOR_CHILD_FLAGS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_KEY_EDITOR_CHILD_FLAGS))
#define IS_KEY_EDITOR_CHILD_FLAGS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_KEY_EDITOR_CHILD_FLAGS))
#define KEY_EDITOR_CHILD_FLAGS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_KEY_EDITOR_CHILD_FLAGS, KeyEditorChildFlagsClass))

typedef struct _KeyEditorChildFlags KeyEditorChildFlags;
typedef struct _KeyEditorChildFlagsClass KeyEditorChildFlagsClass;
typedef struct _KeyEditorChildFlagsPrivate KeyEditorChildFlagsPrivate;
enum  {
	KEY_EDITOR_CHILD_FLAGS_0_PROPERTY,
	KEY_EDITOR_CHILD_FLAGS_NUM_PROPERTIES
};
static GParamSpec* key_editor_child_flags_properties[KEY_EDITOR_CHILD_FLAGS_NUM_PROPERTIES];

#define TYPE_GSETTINGS_KEY (gsettings_key_get_type ())
#define GSETTINGS_KEY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GSETTINGS_KEY, GSettingsKey))
#define GSETTINGS_KEY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GSETTINGS_KEY, GSettingsKeyClass))
#define IS_GSETTINGS_KEY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GSETTINGS_KEY))
#define IS_GSETTINGS_KEY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GSETTINGS_KEY))
#define GSETTINGS_KEY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GSETTINGS_KEY, GSettingsKeyClass))

typedef struct _GSettingsKey GSettingsKey;
typedef struct _GSettingsKeyClass GSettingsKeyClass;

#define TYPE_KEY_EDITOR_CHILD_NULLABLE_BOOL (key_editor_child_nullable_bool_get_type ())
#define KEY_EDITOR_CHILD_NULLABLE_BOOL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_KEY_EDITOR_CHILD_NULLABLE_BOOL, KeyEditorChildNullableBool))
#define KEY_EDITOR_CHILD_NULLABLE_BOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_KEY_EDITOR_CHILD_NULLABLE_BOOL, KeyEditorChildNullableBoolClass))
#define IS_KEY_EDITOR_CHILD_NULLABLE_BOOL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_KEY_EDITOR_CHILD_NULLABLE_BOOL))
#define IS_KEY_EDITOR_CHILD_NULLABLE_BOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_KEY_EDITOR_CHILD_NULLABLE_BOOL))
#define KEY_EDITOR_CHILD_NULLABLE_BOOL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_KEY_EDITOR_CHILD_NULLABLE_BOOL, KeyEditorChildNullableBoolClass))

typedef struct _KeyEditorChildNullableBool KeyEditorChildNullableBool;
typedef struct _KeyEditorChildNullableBoolClass KeyEditorChildNullableBoolClass;
typedef struct _KeyEditorChildNullableBoolPrivate KeyEditorChildNullableBoolPrivate;
enum  {
	KEY_EDITOR_CHILD_NULLABLE_BOOL_0_PROPERTY,
	KEY_EDITOR_CHILD_NULLABLE_BOOL_NUM_PROPERTIES
};
static GParamSpec* key_editor_child_nullable_bool_properties[KEY_EDITOR_CHILD_NULLABLE_BOOL_NUM_PROPERTIES];
typedef struct _Block5Data Block5Data;

#define TYPE_KEY_EDITOR_CHILD_BOOL (key_editor_child_bool_get_type ())
#define KEY_EDITOR_CHILD_BOOL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_KEY_EDITOR_CHILD_BOOL, KeyEditorChildBool))
#define KEY_EDITOR_CHILD_BOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_KEY_EDITOR_CHILD_BOOL, KeyEditorChildBoolClass))
#define IS_KEY_EDITOR_CHILD_BOOL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_KEY_EDITOR_CHILD_BOOL))
#define IS_KEY_EDITOR_CHILD_BOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_KEY_EDITOR_CHILD_BOOL))
#define KEY_EDITOR_CHILD_BOOL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_KEY_EDITOR_CHILD_BOOL, KeyEditorChildBoolClass))

typedef struct _KeyEditorChildBool KeyEditorChildBool;
typedef struct _KeyEditorChildBoolClass KeyEditorChildBoolClass;
typedef struct _KeyEditorChildBoolPrivate KeyEditorChildBoolPrivate;
enum  {
	KEY_EDITOR_CHILD_BOOL_0_PROPERTY,
	KEY_EDITOR_CHILD_BOOL_NUM_PROPERTIES
};
static GParamSpec* key_editor_child_bool_properties[KEY_EDITOR_CHILD_BOOL_NUM_PROPERTIES];

#define TYPE_KEY_EDITOR_CHILD_NUMBER_DOUBLE (key_editor_child_number_double_get_type ())
#define KEY_EDITOR_CHILD_NUMBER_DOUBLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_KEY_EDITOR_CHILD_NUMBER_DOUBLE, KeyEditorChildNumberDouble))
#define KEY_EDITOR_CHILD_NUMBER_DOUBLE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_KEY_EDITOR_CHILD_NUMBER_DOUBLE, KeyEditorChildNumberDoubleClass))
#define IS_KEY_EDITOR_CHILD_NUMBER_DOUBLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_KEY_EDITOR_CHILD_NUMBER_DOUBLE))
#define IS_KEY_EDITOR_CHILD_NUMBER_DOUBLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_KEY_EDITOR_CHILD_NUMBER_DOUBLE))
#define KEY_EDITOR_CHILD_NUMBER_DOUBLE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_KEY_EDITOR_CHILD_NUMBER_DOUBLE, KeyEditorChildNumberDoubleClass))

typedef struct _KeyEditorChildNumberDouble KeyEditorChildNumberDouble;
typedef struct _KeyEditorChildNumberDoubleClass KeyEditorChildNumberDoubleClass;
typedef struct _KeyEditorChildNumberDoublePrivate KeyEditorChildNumberDoublePrivate;
enum  {
	KEY_EDITOR_CHILD_NUMBER_DOUBLE_0_PROPERTY,
	KEY_EDITOR_CHILD_NUMBER_DOUBLE_NUM_PROPERTIES
};
static GParamSpec* key_editor_child_number_double_properties[KEY_EDITOR_CHILD_NUMBER_DOUBLE_NUM_PROPERTIES];
typedef struct _Block6Data Block6Data;

#define TYPE_KEY_EDITOR_CHILD_NUMBER_INT (key_editor_child_number_int_get_type ())
#define KEY_EDITOR_CHILD_NUMBER_INT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_KEY_EDITOR_CHILD_NUMBER_INT, KeyEditorChildNumberInt))
#define KEY_EDITOR_CHILD_NUMBER_INT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_KEY_EDITOR_CHILD_NUMBER_INT, KeyEditorChildNumberIntClass))
#define IS_KEY_EDITOR_CHILD_NUMBER_INT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_KEY_EDITOR_CHILD_NUMBER_INT))
#define IS_KEY_EDITOR_CHILD_NUMBER_INT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_KEY_EDITOR_CHILD_NUMBER_INT))
#define KEY_EDITOR_CHILD_NUMBER_INT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_KEY_EDITOR_CHILD_NUMBER_INT, KeyEditorChildNumberIntClass))

typedef struct _KeyEditorChildNumberInt KeyEditorChildNumberInt;
typedef struct _KeyEditorChildNumberIntClass KeyEditorChildNumberIntClass;
typedef struct _KeyEditorChildNumberIntPrivate KeyEditorChildNumberIntPrivate;
enum  {
	KEY_EDITOR_CHILD_NUMBER_INT_0_PROPERTY,
	KEY_EDITOR_CHILD_NUMBER_INT_NUM_PROPERTIES
};
static GParamSpec* key_editor_child_number_int_properties[KEY_EDITOR_CHILD_NUMBER_INT_NUM_PROPERTIES];
typedef struct _Block7Data Block7Data;

#define TYPE_KEY_EDITOR_CHILD_DEFAULT (key_editor_child_default_get_type ())
#define KEY_EDITOR_CHILD_DEFAULT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_KEY_EDITOR_CHILD_DEFAULT, KeyEditorChildDefault))
#define KEY_EDITOR_CHILD_DEFAULT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_KEY_EDITOR_CHILD_DEFAULT, KeyEditorChildDefaultClass))
#define IS_KEY_EDITOR_CHILD_DEFAULT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_KEY_EDITOR_CHILD_DEFAULT))
#define IS_KEY_EDITOR_CHILD_DEFAULT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_KEY_EDITOR_CHILD_DEFAULT))
#define KEY_EDITOR_CHILD_DEFAULT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_KEY_EDITOR_CHILD_DEFAULT, KeyEditorChildDefaultClass))

typedef struct _KeyEditorChildDefault KeyEditorChildDefault;
typedef struct _KeyEditorChildDefaultClass KeyEditorChildDefaultClass;
typedef struct _KeyEditorChildDefaultPrivate KeyEditorChildDefaultPrivate;
enum  {
	KEY_EDITOR_CHILD_DEFAULT_0_PROPERTY,
	KEY_EDITOR_CHILD_DEFAULT_NUM_PROPERTIES
};
static GParamSpec* key_editor_child_default_properties[KEY_EDITOR_CHILD_DEFAULT_NUM_PROPERTIES];
typedef struct _Block8Data Block8Data;
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
#define _vala_return_if_fail(expr, msg) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return; }
#define _vala_return_val_if_fail(expr, msg, val) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return val; }
#define _vala_warn_if_fail(expr, msg) if G_LIKELY (expr) ; else g_warn_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

struct _KeyEditorChildIface {
	GTypeInterface parent_iface;
	GVariant* (*get_variant) (KeyEditorChild* self);
	void (*reload) (KeyEditorChild* self, GVariant* gvariant);
};

struct _KeyEditorChildSingle {
	GtkLabel parent_instance;
	KeyEditorChildSinglePrivate * priv;
};

struct _KeyEditorChildSingleClass {
	GtkLabelClass parent_class;
};

struct _KeyEditorChildSinglePrivate {
	GVariant* variant;
};

struct _KeyEditorChildEnum {
	GtkMenuButton parent_instance;
	KeyEditorChildEnumPrivate * priv;
};

struct _KeyEditorChildEnumClass {
	GtkMenuButtonClass parent_class;
};

struct _KeyEditorChildEnumPrivate {
	GVariant* variant;
	GAction* action;
};

struct _Block4Data {
	int _ref_count_;
	KeyEditorChildEnum* self;
	ContextPopover* popover;
};

struct _KeyEditorChildFlags {
	GtkGrid parent_instance;
	KeyEditorChildFlagsPrivate * priv;
};

struct _KeyEditorChildFlagsClass {
	GtkGridClass parent_class;
};

struct _KeyEditorChildFlagsPrivate {
	GVariant* variant;
	GtkLabel* label;
};

struct _KeyEditorChildNullableBool {
	GtkMenuButton parent_instance;
	KeyEditorChildNullableBoolPrivate * priv;
};

struct _KeyEditorChildNullableBoolClass {
	GtkMenuButtonClass parent_class;
};

struct _KeyEditorChildNullableBoolPrivate {
	GVariant* variant;
	GVariant* maybe_variant;
	GAction* action;
};

struct _Block5Data {
	int _ref_count_;
	KeyEditorChildNullableBool* self;
	ContextPopover* popover;
};

struct _KeyEditorChildBool {
	GtkBox parent_instance;
	KeyEditorChildBoolPrivate * priv;
};

struct _KeyEditorChildBoolClass {
	GtkBoxClass parent_class;
};

struct _KeyEditorChildBoolPrivate {
	GtkToggleButton* button_true;
};

struct _KeyEditorChildNumberDouble {
	GtkSpinButton parent_instance;
	KeyEditorChildNumberDoublePrivate * priv;
};

struct _KeyEditorChildNumberDoubleClass {
	GtkSpinButtonClass parent_class;
};

struct _KeyEditorChildNumberDoublePrivate {
	gulong deleted_text_handler;
	gulong inserted_text_handler;
};

struct _Block6Data {
	int _ref_count_;
	KeyEditorChildNumberDouble* self;
	GtkEntryBuffer* ref_buffer;
	gulong entry_activate_handler;
};

struct _KeyEditorChildNumberInt {
	GtkSpinButton parent_instance;
	KeyEditorChildNumberIntPrivate * priv;
};

struct _KeyEditorChildNumberIntClass {
	GtkSpinButtonClass parent_class;
};

struct _KeyEditorChildNumberIntPrivate {
	gchar* key_type;
	gulong deleted_text_handler;
	gulong inserted_text_handler;
};

struct _Block7Data {
	int _ref_count_;
	KeyEditorChildNumberInt* self;
	GtkEntryBuffer* ref_buffer;
	gulong entry_activate_handler;
};

struct _KeyEditorChildDefault {
	GtkEntry parent_instance;
	KeyEditorChildDefaultPrivate * priv;
};

struct _KeyEditorChildDefaultClass {
	GtkEntryClass parent_class;
};

struct _KeyEditorChildDefaultPrivate {
	gchar* variant_type;
	GVariant* variant;
	gboolean is_string;
	gulong deleted_text_handler;
	gulong inserted_text_handler;
};

struct _Block8Data {
	int _ref_count_;
	KeyEditorChildDefault* self;
	GtkEntryBuffer* ref_buffer;
	gulong entry_activate_handler;
};


static gpointer key_editor_child_single_parent_class = NULL;
static KeyEditorChildIface * key_editor_child_single_key_editor_child_parent_iface = NULL;
static gpointer key_editor_child_enum_parent_class = NULL;
static KeyEditorChildIface * key_editor_child_enum_key_editor_child_parent_iface = NULL;
static gpointer key_editor_child_flags_parent_class = NULL;
static KeyEditorChildIface * key_editor_child_flags_key_editor_child_parent_iface = NULL;
static gpointer key_editor_child_nullable_bool_parent_class = NULL;
static KeyEditorChildIface * key_editor_child_nullable_bool_key_editor_child_parent_iface = NULL;
static gpointer key_editor_child_bool_parent_class = NULL;
static KeyEditorChildIface * key_editor_child_bool_key_editor_child_parent_iface = NULL;
static gpointer key_editor_child_number_double_parent_class = NULL;
static KeyEditorChildIface * key_editor_child_number_double_key_editor_child_parent_iface = NULL;
static gpointer key_editor_child_number_int_parent_class = NULL;
static KeyEditorChildIface * key_editor_child_number_int_key_editor_child_parent_iface = NULL;
static gpointer key_editor_child_default_parent_class = NULL;
static KeyEditorChildIface * key_editor_child_default_key_editor_child_parent_iface = NULL;

GType key_editor_child_get_type (void) G_GNUC_CONST;
GVariant* key_editor_child_get_variant (KeyEditorChild* self);
void key_editor_child_reload (KeyEditorChild* self, GVariant* gvariant);
GType key_editor_child_single_get_type (void) G_GNUC_CONST;
#define KEY_EDITOR_CHILD_SINGLE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_KEY_EDITOR_CHILD_SINGLE, KeyEditorChildSinglePrivate))
KeyEditorChildSingle* key_editor_child_single_new (GVariant* key_value, const gchar* text);
KeyEditorChildSingle* key_editor_child_single_construct (GType object_type, GVariant* key_value, const gchar* text);
static GVariant* key_editor_child_single_real_get_variant (KeyEditorChild* base);
static void key_editor_child_single_real_reload (KeyEditorChild* base, GVariant* gvariant);
static void key_editor_child_single_finalize (GObject * obj);
GType key_editor_child_enum_get_type (void) G_GNUC_CONST;
#define KEY_EDITOR_CHILD_ENUM_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_KEY_EDITOR_CHILD_ENUM, KeyEditorChildEnumPrivate))
GType setting_object_get_type (void) G_GNUC_CONST;
GType key_get_type (void) G_GNUC_CONST;
KeyEditorChildEnum* key_editor_child_enum_new (Key* key);
KeyEditorChildEnum* key_editor_child_enum_construct (GType object_type, Key* key);
const gchar* key_get_type_string (Key* self);
GType context_popover_get_type (void) G_GNUC_CONST;
static Block4Data* block4_data_ref (Block4Data* _data4_);
static void block4_data_unref (void * _userdata_);
ContextPopover* context_popover_new (void);
ContextPopover* context_popover_construct (GType object_type);
GAction* context_popover_create_buttons_list (ContextPopover* self, Key* key, gboolean has_default_value, gboolean delayed_apply_menu);
static void __lambda30_ (Block4Data* _data4_, GVariant* gvariant);
static void ___lambda30__context_popover_value_changed (ContextPopover* _sender, GVariant* gvariant, gpointer self);
gboolean key_get_planned_change (Key* self);
GVariant* key_get_planned_value (Key* self);
GVariant* key_get_value (Key* self);
static GVariant* key_editor_child_enum_real_get_variant (KeyEditorChild* base);
static void key_editor_child_enum_real_reload (KeyEditorChild* base, GVariant* gvariant);
static void key_editor_child_enum_finalize (GObject * obj);
GType key_editor_child_flags_get_type (void) G_GNUC_CONST;
#define KEY_EDITOR_CHILD_FLAGS_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_KEY_EDITOR_CHILD_FLAGS, KeyEditorChildFlagsPrivate))
GType gsettings_key_get_type (void) G_GNUC_CONST;
KeyEditorChildFlags* key_editor_child_flags_new (GSettingsKey* key);
KeyEditorChildFlags* key_editor_child_flags_construct (GType object_type, GSettingsKey* key);
void context_popover_create_flags_list (ContextPopover* self, GSettingsKey* key);
static void __lambda31_ (KeyEditorChildFlags* self, GVariant* gvariant);
static void ___lambda31__context_popover_value_changed (ContextPopover* _sender, GVariant* gvariant, gpointer self);
static GVariant* key_editor_child_flags_real_get_variant (KeyEditorChild* base);
static void key_editor_child_flags_real_reload (KeyEditorChild* base, GVariant* gvariant);
static void key_editor_child_flags_finalize (GObject * obj);
GType key_editor_child_nullable_bool_get_type (void) G_GNUC_CONST;
#define KEY_EDITOR_CHILD_NULLABLE_BOOL_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_KEY_EDITOR_CHILD_NULLABLE_BOOL, KeyEditorChildNullableBoolPrivate))
KeyEditorChildNullableBool* key_editor_child_nullable_bool_new (Key* key);
KeyEditorChildNullableBool* key_editor_child_nullable_bool_construct (GType object_type, Key* key);
static Block5Data* block5_data_ref (Block5Data* _data5_);
static void block5_data_unref (void * _userdata_);
static void __lambda41_ (Block5Data* _data5_, GVariant* gvariant);
static void ___lambda41__context_popover_value_changed (ContextPopover* _sender, GVariant* gvariant, gpointer self);
static GVariant* key_editor_child_nullable_bool_real_get_variant (KeyEditorChild* base);
static void key_editor_child_nullable_bool_real_reload (KeyEditorChild* base, GVariant* gvariant);
gchar* key_cool_boolean_text_value (gboolean* nullable_boolean, gboolean capitalized);
static void key_editor_child_nullable_bool_finalize (GObject * obj);
GType key_editor_child_bool_get_type (void) G_GNUC_CONST;
#define KEY_EDITOR_CHILD_BOOL_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_KEY_EDITOR_CHILD_BOOL, KeyEditorChildBoolPrivate))
KeyEditorChildBool* key_editor_child_bool_new (gboolean initial_value);
KeyEditorChildBool* key_editor_child_bool_construct (GType object_type, gboolean initial_value);
static void __lambda32_ (KeyEditorChildBool* self);
static void ___lambda32__gtk_toggle_button_toggled (GtkToggleButton* _sender, gpointer self);
static GVariant* key_editor_child_bool_real_get_variant (KeyEditorChild* base);
static void key_editor_child_bool_real_reload (KeyEditorChild* base, GVariant* gvariant);
static void key_editor_child_bool_finalize (GObject * obj);
GType key_editor_child_number_double_get_type (void) G_GNUC_CONST;
#define KEY_EDITOR_CHILD_NUMBER_DOUBLE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_KEY_EDITOR_CHILD_NUMBER_DOUBLE, KeyEditorChildNumberDoublePrivate))
KeyEditorChildNumberDouble* key_editor_child_number_double_new (Key* key);
KeyEditorChildNumberDouble* key_editor_child_number_double_construct (GType object_type, Key* key);
static Block6Data* block6_data_ref (Block6Data* _data6_);
static void block6_data_unref (void * _userdata_);
const gchar* gsettings_key_get_range_type (GSettingsKey* self);
GVariant* gsettings_key_get_range_content (GSettingsKey* self);
static void __lambda37_ (KeyEditorChildNumberDouble* self);
static void ___lambda37__gtk_entry_buffer_deleted_text (GtkEntryBuffer* _sender, guint position, guint n_chars, gpointer self);
static void __lambda38_ (KeyEditorChildNumberDouble* self);
static void ___lambda38__gtk_entry_buffer_inserted_text (GtkEntryBuffer* _sender, guint position, const gchar* chars, guint n_chars, gpointer self);
static void __lambda39_ (KeyEditorChildNumberDouble* self);
static void ___lambda39__gtk_entry_activate (GtkEntry* _sender, gpointer self);
static void __lambda40_ (Block6Data* _data6_);
static void ___lambda40__gtk_widget_destroy (GtkWidget* _sender, gpointer self);
static GVariant* key_editor_child_number_double_real_get_variant (KeyEditorChild* base);
static void key_editor_child_number_double_set_lock (KeyEditorChildNumberDouble* self, gboolean state);
static void key_editor_child_number_double_real_reload (KeyEditorChild* base, GVariant* gvariant);
static void key_editor_child_number_double_finalize (GObject * obj);
GType key_editor_child_number_int_get_type (void) G_GNUC_CONST;
#define KEY_EDITOR_CHILD_NUMBER_INT_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_KEY_EDITOR_CHILD_NUMBER_INT, KeyEditorChildNumberIntPrivate))
KeyEditorChildNumberInt* key_editor_child_number_int_new (Key* key);
KeyEditorChildNumberInt* key_editor_child_number_int_construct (GType object_type, Key* key);
static Block7Data* block7_data_ref (Block7Data* _data7_);
static void block7_data_unref (void * _userdata_);
static gdouble key_editor_child_number_int_get_variant_as_double (GVariant* variant);
static void key_editor_child_number_int_get_min_and_max_double (gdouble* min, gdouble* max, const gchar* variant_type);
static void __lambda33_ (KeyEditorChildNumberInt* self);
static void ___lambda33__gtk_entry_buffer_deleted_text (GtkEntryBuffer* _sender, guint position, guint n_chars, gpointer self);
static void __lambda34_ (KeyEditorChildNumberInt* self);
static void ___lambda34__gtk_entry_buffer_inserted_text (GtkEntryBuffer* _sender, guint position, const gchar* chars, guint n_chars, gpointer self);
static void __lambda35_ (KeyEditorChildNumberInt* self);
static void ___lambda35__gtk_entry_activate (GtkEntry* _sender, gpointer self);
static void __lambda36_ (Block7Data* _data7_);
static void ___lambda36__gtk_widget_destroy (GtkWidget* _sender, gpointer self);
static GVariant* key_editor_child_number_int_real_get_variant (KeyEditorChild* base);
static gint64 key_editor_child_number_int_get_int64_from_entry (KeyEditorChildNumberInt* self);
static void key_editor_child_number_int_set_lock (KeyEditorChildNumberInt* self, gboolean state);
static void key_editor_child_number_int_real_reload (KeyEditorChild* base, GVariant* gvariant);
static void key_editor_child_number_int_finalize (GObject * obj);
GType key_editor_child_default_get_type (void) G_GNUC_CONST;
#define KEY_EDITOR_CHILD_DEFAULT_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_KEY_EDITOR_CHILD_DEFAULT, KeyEditorChildDefaultPrivate))
KeyEditorChildDefault* key_editor_child_default_new (const gchar* type, GVariant* initial_value);
KeyEditorChildDefault* key_editor_child_default_construct (GType object_type, const gchar* type, GVariant* initial_value);
static Block8Data* block8_data_ref (Block8Data* _data8_);
static void block8_data_unref (void * _userdata_);
static void __lambda42_ (KeyEditorChildDefault* self);
static gboolean key_editor_child_default_test_value (KeyEditorChildDefault* self);
static void ___lambda42__gtk_entry_buffer_deleted_text (GtkEntryBuffer* _sender, guint position, guint n_chars, gpointer self);
static void __lambda43_ (KeyEditorChildDefault* self);
static void ___lambda43__gtk_entry_buffer_inserted_text (GtkEntryBuffer* _sender, guint position, const gchar* chars, guint n_chars, gpointer self);
static void __lambda44_ (KeyEditorChildDefault* self);
static void ___lambda44__gtk_entry_activate (GtkEntry* _sender, gpointer self);
static void __lambda45_ (Block8Data* _data8_);
static void ___lambda45__gtk_widget_destroy (GtkWidget* _sender, gpointer self);
static GVariant* key_editor_child_default_real_get_variant (KeyEditorChild* base);
static void key_editor_child_default_set_lock (KeyEditorChildDefault* self, gboolean state);
static void key_editor_child_default_real_reload (KeyEditorChild* base, GVariant* gvariant);
static void key_editor_child_default_finalize (GObject * obj);


GVariant* key_editor_child_get_variant (KeyEditorChild* self) {
	g_return_val_if_fail (self != NULL, NULL);
	return KEY_EDITOR_CHILD_GET_INTERFACE (self)->get_variant (self);
}


void key_editor_child_reload (KeyEditorChild* self, GVariant* gvariant) {
	g_return_if_fail (self != NULL);
	KEY_EDITOR_CHILD_GET_INTERFACE (self)->reload (self, gvariant);
}


static void key_editor_child_base_init (KeyEditorChildIface * iface) {
	static gboolean initialized = FALSE;
	if (!initialized) {
		initialized = TRUE;
		key_editor_child_signals[KEY_EDITOR_CHILD_VALUE_HAS_CHANGED_SIGNAL] = g_signal_new ("value-has-changed", TYPE_KEY_EDITOR_CHILD, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__BOOLEAN, G_TYPE_NONE, 1, G_TYPE_BOOLEAN);
		key_editor_child_signals[KEY_EDITOR_CHILD_CHILD_ACTIVATED_SIGNAL] = g_signal_new ("child-activated", TYPE_KEY_EDITOR_CHILD, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	}
}


GType key_editor_child_get_type (void) {
	static volatile gsize key_editor_child_type_id__volatile = 0;
	if (g_once_init_enter (&key_editor_child_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (KeyEditorChildIface), (GBaseInitFunc) key_editor_child_base_init, (GBaseFinalizeFunc) NULL, (GClassInitFunc) NULL, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
		GType key_editor_child_type_id;
		key_editor_child_type_id = g_type_register_static (G_TYPE_INTERFACE, "KeyEditorChild", &g_define_type_info, 0);
		g_type_interface_add_prerequisite (key_editor_child_type_id, gtk_widget_get_type ());
		g_once_init_leave (&key_editor_child_type_id__volatile, key_editor_child_type_id);
	}
	return key_editor_child_type_id__volatile;
}


static gpointer _g_variant_ref0 (gpointer self) {
	return self ? g_variant_ref (self) : NULL;
}


KeyEditorChildSingle* key_editor_child_single_construct (GType object_type, GVariant* key_value, const gchar* text) {
	KeyEditorChildSingle * self = NULL;
	GVariant* _tmp0_;
	GVariant* _tmp1_;
	const gchar* _tmp2_;
	g_return_val_if_fail (key_value != NULL, NULL);
	g_return_val_if_fail (text != NULL, NULL);
	self = (KeyEditorChildSingle*) g_object_new (object_type, NULL);
	_tmp0_ = key_value;
	_tmp1_ = _g_variant_ref0 (_tmp0_);
	_g_variant_unref0 (self->priv->variant);
	self->priv->variant = _tmp1_;
	_tmp2_ = text;
	gtk_label_set_label ((GtkLabel*) self, _tmp2_);
	gtk_widget_show ((GtkWidget*) self);
	return self;
}


KeyEditorChildSingle* key_editor_child_single_new (GVariant* key_value, const gchar* text) {
	return key_editor_child_single_construct (TYPE_KEY_EDITOR_CHILD_SINGLE, key_value, text);
}


static GVariant* key_editor_child_single_real_get_variant (KeyEditorChild* base) {
	KeyEditorChildSingle * self;
	GVariant* result = NULL;
	GVariant* _tmp0_;
	GVariant* _tmp1_;
	self = (KeyEditorChildSingle*) base;
	_tmp0_ = self->priv->variant;
	_tmp1_ = _g_variant_ref0 (_tmp0_);
	result = _tmp1_;
	return result;
}


static void key_editor_child_single_real_reload (KeyEditorChild* base, GVariant* gvariant) {
	KeyEditorChildSingle * self;
	self = (KeyEditorChildSingle*) base;
	g_return_if_fail (gvariant != NULL);
}


static void key_editor_child_single_class_init (KeyEditorChildSingleClass * klass) {
	key_editor_child_single_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (KeyEditorChildSinglePrivate));
	G_OBJECT_CLASS (klass)->finalize = key_editor_child_single_finalize;
}


static void key_editor_child_single_key_editor_child_interface_init (KeyEditorChildIface * iface) {
	key_editor_child_single_key_editor_child_parent_iface = g_type_interface_peek_parent (iface);
	iface->get_variant = (GVariant* (*) (KeyEditorChild *)) key_editor_child_single_real_get_variant;
	iface->reload = (void (*) (KeyEditorChild *, GVariant*)) key_editor_child_single_real_reload;
}


static void key_editor_child_single_instance_init (KeyEditorChildSingle * self) {
	self->priv = KEY_EDITOR_CHILD_SINGLE_GET_PRIVATE (self);
}


static void key_editor_child_single_finalize (GObject * obj) {
	KeyEditorChildSingle * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_KEY_EDITOR_CHILD_SINGLE, KeyEditorChildSingle);
	_g_variant_unref0 (self->priv->variant);
	G_OBJECT_CLASS (key_editor_child_single_parent_class)->finalize (obj);
}


GType key_editor_child_single_get_type (void) {
	static volatile gsize key_editor_child_single_type_id__volatile = 0;
	if (g_once_init_enter (&key_editor_child_single_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (KeyEditorChildSingleClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) key_editor_child_single_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (KeyEditorChildSingle), 0, (GInstanceInitFunc) key_editor_child_single_instance_init, NULL };
		static const GInterfaceInfo key_editor_child_info = { (GInterfaceInitFunc) key_editor_child_single_key_editor_child_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType key_editor_child_single_type_id;
		key_editor_child_single_type_id = g_type_register_static (gtk_label_get_type (), "KeyEditorChildSingle", &g_define_type_info, 0);
		g_type_add_interface_static (key_editor_child_single_type_id, TYPE_KEY_EDITOR_CHILD, &key_editor_child_info);
		g_once_init_leave (&key_editor_child_single_type_id__volatile, key_editor_child_single_type_id);
	}
	return key_editor_child_single_type_id__volatile;
}


static Block4Data* block4_data_ref (Block4Data* _data4_) {
	g_atomic_int_inc (&_data4_->_ref_count_);
	return _data4_;
}


static void block4_data_unref (void * _userdata_) {
	Block4Data* _data4_;
	_data4_ = (Block4Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data4_->_ref_count_)) {
		KeyEditorChildEnum* self;
		self = _data4_->self;
		_g_object_unref0 (_data4_->popover);
		_g_object_unref0 (self);
		g_slice_free (Block4Data, _data4_);
	}
}


static void __lambda30_ (Block4Data* _data4_, GVariant* gvariant) {
	KeyEditorChildEnum* self;
	GVariant* _tmp0_;
	GVariant* _tmp1_;
	ContextPopover* _tmp2_;
	self = _data4_->self;
	_tmp0_ = gvariant;
	if (_tmp0_ == NULL) {
		g_assert_not_reached ();
	}
	_tmp1_ = gvariant;
	key_editor_child_reload ((KeyEditorChild*) self, (GVariant*) _tmp1_);
	_tmp2_ = _data4_->popover;
	g_signal_emit_by_name ((GtkPopover*) _tmp2_, "closed");
	g_signal_emit ((KeyEditorChild*) self, key_editor_child_signals[KEY_EDITOR_CHILD_VALUE_HAS_CHANGED_SIGNAL], 0, TRUE);
}


static void ___lambda30__context_popover_value_changed (ContextPopover* _sender, GVariant* gvariant, gpointer self) {
	__lambda30_ (self, gvariant);
}


KeyEditorChildEnum* key_editor_child_enum_construct (GType object_type, Key* key) {
	KeyEditorChildEnum * self = NULL;
	Key* _tmp0_;
	const gchar* _tmp1_;
	const gchar* _tmp2_;
	Block4Data* _data4_;
	ContextPopover* _tmp3_;
	ContextPopover* _tmp4_;
	Key* _tmp5_;
	GAction* _tmp6_;
	ContextPopover* _tmp7_;
	ContextPopover* _tmp8_;
	GVariant* _tmp9_ = NULL;
	gboolean _tmp10_ = FALSE;
	Key* _tmp11_;
	gboolean _tmp12_;
	gboolean _tmp13_;
	ContextPopover* _tmp24_;
	g_return_val_if_fail (key != NULL, NULL);
	_tmp0_ = key;
	_tmp1_ = key_get_type_string (_tmp0_);
	_tmp2_ = _tmp1_;
	_vala_return_val_if_fail (g_strcmp0 (_tmp2_, "<enum>") == 0, "key.type_string == \"<enum>\"", NULL);
	_data4_ = g_slice_new0 (Block4Data);
	_data4_->_ref_count_ = 1;
	self = (KeyEditorChildEnum*) g_object_new (object_type, NULL);
	_data4_->self = g_object_ref (self);
	gtk_widget_set_visible ((GtkWidget*) self, TRUE);
	gtk_widget_set_hexpand ((GtkWidget*) self, TRUE);
	gtk_widget_set_halign ((GtkWidget*) self, GTK_ALIGN_START);
	gtk_menu_button_set_use_popover ((GtkMenuButton*) self, TRUE);
	g_object_set ((GtkWidget*) self, "width-request", 100, NULL);
	_tmp3_ = context_popover_new ();
	g_object_ref_sink (_tmp3_);
	_data4_->popover = _tmp3_;
	_tmp4_ = _data4_->popover;
	_tmp5_ = key;
	_tmp6_ = context_popover_create_buttons_list (_tmp4_, _tmp5_, FALSE, FALSE);
	_g_object_unref0 (self->priv->action);
	self->priv->action = _tmp6_;
	_tmp7_ = _data4_->popover;
	gtk_popover_set_relative_to ((GtkPopover*) _tmp7_, (GtkWidget*) self);
	_tmp8_ = _data4_->popover;
	g_signal_connect_data (_tmp8_, "value-changed", (GCallback) ___lambda30__context_popover_value_changed, block4_data_ref (_data4_), (GClosureNotify) block4_data_unref, 0);
	_tmp11_ = key;
	_tmp12_ = key_get_planned_change (_tmp11_);
	_tmp13_ = _tmp12_;
	if (_tmp13_) {
		Key* _tmp14_;
		GVariant* _tmp15_;
		GVariant* _tmp16_;
		_tmp14_ = key;
		_tmp15_ = key_get_planned_value (_tmp14_);
		_tmp16_ = _tmp15_;
		_tmp10_ = _tmp16_ != NULL;
	} else {
		_tmp10_ = FALSE;
	}
	if (_tmp10_) {
		Key* _tmp17_;
		GVariant* _tmp18_;
		GVariant* _tmp19_;
		GVariant* _tmp20_;
		_tmp17_ = key;
		_tmp18_ = key_get_planned_value (_tmp17_);
		_tmp19_ = _tmp18_;
		_tmp20_ = _g_variant_ref0 ((GVariant*) _tmp19_);
		_g_variant_unref0 (_tmp9_);
		_tmp9_ = _tmp20_;
	} else {
		Key* _tmp21_;
		GVariant* _tmp22_;
		GVariant* _tmp23_;
		_tmp21_ = key;
		_tmp22_ = key_get_value (_tmp21_);
		_tmp23_ = _tmp22_;
		_g_variant_unref0 (_tmp9_);
		_tmp9_ = _tmp23_;
	}
	key_editor_child_reload ((KeyEditorChild*) self, _tmp9_);
	_tmp24_ = _data4_->popover;
	gtk_menu_button_set_popover ((GtkMenuButton*) self, (GtkWidget*) G_TYPE_CHECK_INSTANCE_CAST (_tmp24_, gtk_popover_get_type (), GtkPopover));
	_g_variant_unref0 (_tmp9_);
	block4_data_unref (_data4_);
	_data4_ = NULL;
	return self;
}


KeyEditorChildEnum* key_editor_child_enum_new (Key* key) {
	return key_editor_child_enum_construct (TYPE_KEY_EDITOR_CHILD_ENUM, key);
}


static GVariant* key_editor_child_enum_real_get_variant (KeyEditorChild* base) {
	KeyEditorChildEnum * self;
	GVariant* result = NULL;
	GVariant* _tmp0_;
	GVariant* _tmp1_;
	self = (KeyEditorChildEnum*) base;
	_tmp0_ = self->priv->variant;
	_tmp1_ = _g_variant_ref0 (_tmp0_);
	result = _tmp1_;
	return result;
}


static gpointer _g_variant_type_copy0 (gpointer self) {
	return self ? g_variant_type_copy (self) : NULL;
}


static void key_editor_child_enum_real_reload (KeyEditorChild* base, GVariant* gvariant) {
	KeyEditorChildEnum * self;
	GVariant* _tmp0_;
	GVariant* _tmp1_;
	GVariantType* type = NULL;
	GVariant* _tmp2_;
	const GVariantType* _tmp3_;
	GVariantType* _tmp4_;
	gchar* _tmp5_ = NULL;
	const GVariantType* _tmp6_;
	const GVariantType* _tmp7_;
	GAction* _tmp13_;
	const GVariantType* _tmp14_;
	GVariant* _tmp15_;
	GVariant* _tmp16_;
	GVariant* _tmp17_;
	GVariant* _tmp18_;
	GVariant* _tmp19_;
	self = (KeyEditorChildEnum*) base;
	g_return_if_fail (gvariant != NULL);
	_tmp0_ = gvariant;
	_tmp1_ = _g_variant_ref0 (_tmp0_);
	_g_variant_unref0 (self->priv->variant);
	self->priv->variant = _tmp1_;
	_tmp2_ = gvariant;
	_tmp3_ = g_variant_get_type (_tmp2_);
	_tmp4_ = _g_variant_type_copy0 (_tmp3_);
	type = _tmp4_;
	_tmp6_ = type;
	_tmp7_ = G_VARIANT_TYPE_STRING;
	if (_tmp6_ == _tmp7_) {
		GVariant* _tmp8_;
		const gchar* _tmp9_;
		gchar* _tmp10_;
		_tmp8_ = gvariant;
		_tmp9_ = g_variant_get_string (_tmp8_, NULL);
		_tmp10_ = g_strdup (_tmp9_);
		_g_free0 (_tmp5_);
		_tmp5_ = _tmp10_;
	} else {
		GVariant* _tmp11_;
		gchar* _tmp12_;
		_tmp11_ = gvariant;
		_tmp12_ = g_variant_print (_tmp11_, FALSE);
		_g_free0 (_tmp5_);
		_tmp5_ = _tmp12_;
	}
	gtk_button_set_label ((GtkButton*) self, _tmp5_);
	_tmp13_ = self->priv->action;
	_tmp14_ = type;
	_tmp15_ = gvariant;
	_tmp16_ = g_variant_new_maybe (_tmp14_, _tmp15_);
	g_variant_ref_sink (_tmp16_);
	_tmp17_ = _tmp16_;
	_tmp18_ = g_variant_new_maybe (NULL, _tmp17_);
	g_variant_ref_sink (_tmp18_);
	_tmp19_ = _tmp18_;
	g_action_change_state (_tmp13_, _tmp19_);
	_g_variant_unref0 (_tmp19_);
	_g_variant_unref0 (_tmp17_);
	_g_free0 (_tmp5_);
	_g_variant_type_free0 (type);
}


static void key_editor_child_enum_class_init (KeyEditorChildEnumClass * klass) {
	key_editor_child_enum_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (KeyEditorChildEnumPrivate));
	G_OBJECT_CLASS (klass)->finalize = key_editor_child_enum_finalize;
}


static void key_editor_child_enum_key_editor_child_interface_init (KeyEditorChildIface * iface) {
	key_editor_child_enum_key_editor_child_parent_iface = g_type_interface_peek_parent (iface);
	iface->get_variant = (GVariant* (*) (KeyEditorChild *)) key_editor_child_enum_real_get_variant;
	iface->reload = (void (*) (KeyEditorChild *, GVariant*)) key_editor_child_enum_real_reload;
}


static void key_editor_child_enum_instance_init (KeyEditorChildEnum * self) {
	self->priv = KEY_EDITOR_CHILD_ENUM_GET_PRIVATE (self);
}


static void key_editor_child_enum_finalize (GObject * obj) {
	KeyEditorChildEnum * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_KEY_EDITOR_CHILD_ENUM, KeyEditorChildEnum);
	_g_variant_unref0 (self->priv->variant);
	_g_object_unref0 (self->priv->action);
	G_OBJECT_CLASS (key_editor_child_enum_parent_class)->finalize (obj);
}


GType key_editor_child_enum_get_type (void) {
	static volatile gsize key_editor_child_enum_type_id__volatile = 0;
	if (g_once_init_enter (&key_editor_child_enum_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (KeyEditorChildEnumClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) key_editor_child_enum_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (KeyEditorChildEnum), 0, (GInstanceInitFunc) key_editor_child_enum_instance_init, NULL };
		static const GInterfaceInfo key_editor_child_info = { (GInterfaceInitFunc) key_editor_child_enum_key_editor_child_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType key_editor_child_enum_type_id;
		key_editor_child_enum_type_id = g_type_register_static (gtk_menu_button_get_type (), "KeyEditorChildEnum", &g_define_type_info, 0);
		g_type_add_interface_static (key_editor_child_enum_type_id, TYPE_KEY_EDITOR_CHILD, &key_editor_child_info);
		g_once_init_leave (&key_editor_child_enum_type_id__volatile, key_editor_child_enum_type_id);
	}
	return key_editor_child_enum_type_id__volatile;
}


static void __lambda31_ (KeyEditorChildFlags* self, GVariant* gvariant) {
	GVariant* _tmp0_;
	GVariant* _tmp1_;
	_tmp0_ = gvariant;
	if (_tmp0_ == NULL) {
		g_assert_not_reached ();
	}
	_tmp1_ = gvariant;
	key_editor_child_reload ((KeyEditorChild*) self, (GVariant*) _tmp1_);
	g_signal_emit ((KeyEditorChild*) self, key_editor_child_signals[KEY_EDITOR_CHILD_VALUE_HAS_CHANGED_SIGNAL], 0, TRUE);
}


static void ___lambda31__context_popover_value_changed (ContextPopover* _sender, GVariant* gvariant, gpointer self) {
	__lambda31_ ((KeyEditorChildFlags*) self, gvariant);
}


KeyEditorChildFlags* key_editor_child_flags_construct (GType object_type, GSettingsKey* key) {
	KeyEditorChildFlags * self = NULL;
	GSettingsKey* _tmp0_;
	const gchar* _tmp1_;
	const gchar* _tmp2_;
	GtkMenuButton* button = NULL;
	GtkMenuButton* _tmp3_;
	GtkMenuButton* _tmp4_;
	GtkMenuButton* _tmp5_;
	GtkMenuButton* _tmp6_;
	GtkMenuButton* _tmp7_;
	GtkStyleContext* _tmp8_;
	GtkMenuButton* _tmp9_;
	GtkLabel* _tmp10_;
	GtkLabel* _tmp11_;
	GtkLabel* _tmp12_;
	GtkLabel* _tmp13_;
	ContextPopover* popover = NULL;
	ContextPopover* _tmp14_;
	ContextPopover* _tmp15_;
	GSettingsKey* _tmp16_;
	ContextPopover* _tmp17_;
	GtkMenuButton* _tmp18_;
	ContextPopover* _tmp19_;
	GVariant* _tmp20_ = NULL;
	gboolean _tmp21_ = FALSE;
	GSettingsKey* _tmp22_;
	gboolean _tmp23_;
	gboolean _tmp24_;
	GtkMenuButton* _tmp35_;
	ContextPopover* _tmp36_;
	g_return_val_if_fail (key != NULL, NULL);
	_tmp0_ = key;
	_tmp1_ = key_get_type_string ((Key*) _tmp0_);
	_tmp2_ = _tmp1_;
	_vala_return_val_if_fail (g_strcmp0 (_tmp2_, "<flags>") == 0, "key.type_string == \"<flags>\"", NULL);
	self = (KeyEditorChildFlags*) g_object_new (object_type, NULL);
	gtk_widget_set_visible ((GtkWidget*) self, TRUE);
	gtk_widget_set_hexpand ((GtkWidget*) self, TRUE);
	gtk_orientable_set_orientation ((GtkOrientable*) self, GTK_ORIENTATION_HORIZONTAL);
	gtk_grid_set_column_spacing ((GtkGrid*) self, 8);
	_tmp3_ = (GtkMenuButton*) gtk_menu_button_new ();
	g_object_ref_sink (_tmp3_);
	button = _tmp3_;
	_tmp4_ = button;
	gtk_widget_set_visible ((GtkWidget*) _tmp4_, TRUE);
	_tmp5_ = button;
	gtk_menu_button_set_use_popover (_tmp5_, TRUE);
	_tmp6_ = button;
	gtk_widget_set_halign ((GtkWidget*) _tmp6_, GTK_ALIGN_START);
	_tmp7_ = button;
	_tmp8_ = gtk_widget_get_style_context ((GtkWidget*) _tmp7_);
	gtk_style_context_add_class (_tmp8_, "image-button");
	_tmp9_ = button;
	gtk_container_add ((GtkContainer*) self, (GtkWidget*) _tmp9_);
	_tmp10_ = self->priv->label;
	gtk_widget_set_visible ((GtkWidget*) _tmp10_, TRUE);
	_tmp11_ = self->priv->label;
	gtk_widget_set_halign ((GtkWidget*) _tmp11_, GTK_ALIGN_START);
	_tmp12_ = self->priv->label;
	gtk_widget_set_hexpand ((GtkWidget*) _tmp12_, TRUE);
	_tmp13_ = self->priv->label;
	gtk_container_add ((GtkContainer*) self, (GtkWidget*) _tmp13_);
	_tmp14_ = context_popover_new ();
	g_object_ref_sink (_tmp14_);
	popover = _tmp14_;
	_tmp15_ = popover;
	_tmp16_ = key;
	context_popover_create_flags_list (_tmp15_, _tmp16_);
	_tmp17_ = popover;
	_tmp18_ = button;
	gtk_popover_set_relative_to ((GtkPopover*) _tmp17_, (GtkWidget*) _tmp18_);
	_tmp19_ = popover;
	g_signal_connect_object (_tmp19_, "value-changed", (GCallback) ___lambda31__context_popover_value_changed, self, 0);
	_tmp22_ = key;
	_tmp23_ = key_get_planned_change ((Key*) _tmp22_);
	_tmp24_ = _tmp23_;
	if (_tmp24_) {
		GSettingsKey* _tmp25_;
		GVariant* _tmp26_;
		GVariant* _tmp27_;
		_tmp25_ = key;
		_tmp26_ = key_get_planned_value ((Key*) _tmp25_);
		_tmp27_ = _tmp26_;
		_tmp21_ = _tmp27_ != NULL;
	} else {
		_tmp21_ = FALSE;
	}
	if (_tmp21_) {
		GSettingsKey* _tmp28_;
		GVariant* _tmp29_;
		GVariant* _tmp30_;
		GVariant* _tmp31_;
		_tmp28_ = key;
		_tmp29_ = key_get_planned_value ((Key*) _tmp28_);
		_tmp30_ = _tmp29_;
		_tmp31_ = _g_variant_ref0 ((GVariant*) _tmp30_);
		_g_variant_unref0 (_tmp20_);
		_tmp20_ = _tmp31_;
	} else {
		GSettingsKey* _tmp32_;
		GVariant* _tmp33_;
		GVariant* _tmp34_;
		_tmp32_ = key;
		_tmp33_ = key_get_value ((Key*) _tmp32_);
		_tmp34_ = _tmp33_;
		_g_variant_unref0 (_tmp20_);
		_tmp20_ = _tmp34_;
	}
	key_editor_child_reload ((KeyEditorChild*) self, _tmp20_);
	_tmp35_ = button;
	_tmp36_ = popover;
	gtk_menu_button_set_popover (_tmp35_, (GtkWidget*) G_TYPE_CHECK_INSTANCE_CAST (_tmp36_, gtk_popover_get_type (), GtkPopover));
	_g_variant_unref0 (_tmp20_);
	_g_object_unref0 (popover);
	_g_object_unref0 (button);
	return self;
}


KeyEditorChildFlags* key_editor_child_flags_new (GSettingsKey* key) {
	return key_editor_child_flags_construct (TYPE_KEY_EDITOR_CHILD_FLAGS, key);
}


static GVariant* key_editor_child_flags_real_get_variant (KeyEditorChild* base) {
	KeyEditorChildFlags * self;
	GVariant* result = NULL;
	GVariant* _tmp0_;
	GVariant* _tmp1_;
	self = (KeyEditorChildFlags*) base;
	_tmp0_ = self->priv->variant;
	_tmp1_ = _g_variant_ref0 (_tmp0_);
	result = _tmp1_;
	return result;
}


static void key_editor_child_flags_real_reload (KeyEditorChild* base, GVariant* gvariant) {
	KeyEditorChildFlags * self;
	GVariant* _tmp0_;
	GVariant* _tmp1_;
	GtkLabel* _tmp2_;
	GVariant* _tmp3_;
	gchar* _tmp4_;
	gchar* _tmp5_;
	self = (KeyEditorChildFlags*) base;
	g_return_if_fail (gvariant != NULL);
	_tmp0_ = gvariant;
	_tmp1_ = _g_variant_ref0 (_tmp0_);
	_g_variant_unref0 (self->priv->variant);
	self->priv->variant = _tmp1_;
	_tmp2_ = self->priv->label;
	_tmp3_ = gvariant;
	_tmp4_ = g_variant_print (_tmp3_, FALSE);
	_tmp5_ = _tmp4_;
	gtk_label_set_label (_tmp2_, _tmp5_);
	_g_free0 (_tmp5_);
}


static void key_editor_child_flags_class_init (KeyEditorChildFlagsClass * klass) {
	key_editor_child_flags_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (KeyEditorChildFlagsPrivate));
	G_OBJECT_CLASS (klass)->finalize = key_editor_child_flags_finalize;
}


static void key_editor_child_flags_key_editor_child_interface_init (KeyEditorChildIface * iface) {
	key_editor_child_flags_key_editor_child_parent_iface = g_type_interface_peek_parent (iface);
	iface->get_variant = (GVariant* (*) (KeyEditorChild *)) key_editor_child_flags_real_get_variant;
	iface->reload = (void (*) (KeyEditorChild *, GVariant*)) key_editor_child_flags_real_reload;
}


static void key_editor_child_flags_instance_init (KeyEditorChildFlags * self) {
	GtkLabel* _tmp0_;
	self->priv = KEY_EDITOR_CHILD_FLAGS_GET_PRIVATE (self);
	_tmp0_ = (GtkLabel*) gtk_label_new ("");
	g_object_ref_sink (_tmp0_);
	self->priv->label = _tmp0_;
}


static void key_editor_child_flags_finalize (GObject * obj) {
	KeyEditorChildFlags * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_KEY_EDITOR_CHILD_FLAGS, KeyEditorChildFlags);
	_g_variant_unref0 (self->priv->variant);
	_g_object_unref0 (self->priv->label);
	G_OBJECT_CLASS (key_editor_child_flags_parent_class)->finalize (obj);
}


GType key_editor_child_flags_get_type (void) {
	static volatile gsize key_editor_child_flags_type_id__volatile = 0;
	if (g_once_init_enter (&key_editor_child_flags_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (KeyEditorChildFlagsClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) key_editor_child_flags_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (KeyEditorChildFlags), 0, (GInstanceInitFunc) key_editor_child_flags_instance_init, NULL };
		static const GInterfaceInfo key_editor_child_info = { (GInterfaceInitFunc) key_editor_child_flags_key_editor_child_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType key_editor_child_flags_type_id;
		key_editor_child_flags_type_id = g_type_register_static (gtk_grid_get_type (), "KeyEditorChildFlags", &g_define_type_info, 0);
		g_type_add_interface_static (key_editor_child_flags_type_id, TYPE_KEY_EDITOR_CHILD, &key_editor_child_info);
		g_once_init_leave (&key_editor_child_flags_type_id__volatile, key_editor_child_flags_type_id);
	}
	return key_editor_child_flags_type_id__volatile;
}


static Block5Data* block5_data_ref (Block5Data* _data5_) {
	g_atomic_int_inc (&_data5_->_ref_count_);
	return _data5_;
}


static void block5_data_unref (void * _userdata_) {
	Block5Data* _data5_;
	_data5_ = (Block5Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data5_->_ref_count_)) {
		KeyEditorChildNullableBool* self;
		self = _data5_->self;
		_g_object_unref0 (_data5_->popover);
		_g_object_unref0 (self);
		g_slice_free (Block5Data, _data5_);
	}
}


static void __lambda41_ (Block5Data* _data5_, GVariant* gvariant) {
	KeyEditorChildNullableBool* self;
	GVariant* _tmp0_;
	GVariant* _tmp1_;
	ContextPopover* _tmp2_;
	self = _data5_->self;
	_tmp0_ = gvariant;
	if (_tmp0_ == NULL) {
		g_assert_not_reached ();
	}
	_tmp1_ = gvariant;
	key_editor_child_reload ((KeyEditorChild*) self, (GVariant*) _tmp1_);
	_tmp2_ = _data5_->popover;
	g_signal_emit_by_name ((GtkPopover*) _tmp2_, "closed");
	g_signal_emit ((KeyEditorChild*) self, key_editor_child_signals[KEY_EDITOR_CHILD_VALUE_HAS_CHANGED_SIGNAL], 0, TRUE);
}


static void ___lambda41__context_popover_value_changed (ContextPopover* _sender, GVariant* gvariant, gpointer self) {
	__lambda41_ (self, gvariant);
}


KeyEditorChildNullableBool* key_editor_child_nullable_bool_construct (GType object_type, Key* key) {
	KeyEditorChildNullableBool * self = NULL;
	Key* _tmp0_;
	const gchar* _tmp1_;
	const gchar* _tmp2_;
	Block5Data* _data5_;
	ContextPopover* _tmp3_;
	ContextPopover* _tmp4_;
	Key* _tmp5_;
	GAction* _tmp6_;
	ContextPopover* _tmp7_;
	ContextPopover* _tmp8_;
	GVariant* _tmp9_ = NULL;
	gboolean _tmp10_ = FALSE;
	Key* _tmp11_;
	gboolean _tmp12_;
	gboolean _tmp13_;
	ContextPopover* _tmp24_;
	g_return_val_if_fail (key != NULL, NULL);
	_tmp0_ = key;
	_tmp1_ = key_get_type_string (_tmp0_);
	_tmp2_ = _tmp1_;
	_vala_return_val_if_fail (g_strcmp0 (_tmp2_, "mb") == 0, "key.type_string == \"mb\"", NULL);
	_data5_ = g_slice_new0 (Block5Data);
	_data5_->_ref_count_ = 1;
	self = (KeyEditorChildNullableBool*) g_object_new (object_type, NULL);
	_data5_->self = g_object_ref (self);
	gtk_widget_set_visible ((GtkWidget*) self, TRUE);
	gtk_widget_set_hexpand ((GtkWidget*) self, TRUE);
	gtk_widget_set_halign ((GtkWidget*) self, GTK_ALIGN_START);
	gtk_menu_button_set_use_popover ((GtkMenuButton*) self, TRUE);
	g_object_set ((GtkWidget*) self, "width-request", 100, NULL);
	_tmp3_ = context_popover_new ();
	g_object_ref_sink (_tmp3_);
	_data5_->popover = _tmp3_;
	_tmp4_ = _data5_->popover;
	_tmp5_ = key;
	_tmp6_ = context_popover_create_buttons_list (_tmp4_, _tmp5_, FALSE, FALSE);
	_g_object_unref0 (self->priv->action);
	self->priv->action = _tmp6_;
	_tmp7_ = _data5_->popover;
	gtk_popover_set_relative_to ((GtkPopover*) _tmp7_, (GtkWidget*) self);
	_tmp8_ = _data5_->popover;
	g_signal_connect_data (_tmp8_, "value-changed", (GCallback) ___lambda41__context_popover_value_changed, block5_data_ref (_data5_), (GClosureNotify) block5_data_unref, 0);
	_tmp11_ = key;
	_tmp12_ = key_get_planned_change (_tmp11_);
	_tmp13_ = _tmp12_;
	if (_tmp13_) {
		Key* _tmp14_;
		GVariant* _tmp15_;
		GVariant* _tmp16_;
		_tmp14_ = key;
		_tmp15_ = key_get_planned_value (_tmp14_);
		_tmp16_ = _tmp15_;
		_tmp10_ = _tmp16_ != NULL;
	} else {
		_tmp10_ = FALSE;
	}
	if (_tmp10_) {
		Key* _tmp17_;
		GVariant* _tmp18_;
		GVariant* _tmp19_;
		GVariant* _tmp20_;
		_tmp17_ = key;
		_tmp18_ = key_get_planned_value (_tmp17_);
		_tmp19_ = _tmp18_;
		_tmp20_ = _g_variant_ref0 ((GVariant*) _tmp19_);
		_g_variant_unref0 (_tmp9_);
		_tmp9_ = _tmp20_;
	} else {
		Key* _tmp21_;
		GVariant* _tmp22_;
		GVariant* _tmp23_;
		_tmp21_ = key;
		_tmp22_ = key_get_value (_tmp21_);
		_tmp23_ = _tmp22_;
		_g_variant_unref0 (_tmp9_);
		_tmp9_ = _tmp23_;
	}
	key_editor_child_reload ((KeyEditorChild*) self, _tmp9_);
	_tmp24_ = _data5_->popover;
	gtk_menu_button_set_popover ((GtkMenuButton*) self, (GtkWidget*) G_TYPE_CHECK_INSTANCE_CAST (_tmp24_, gtk_popover_get_type (), GtkPopover));
	_g_variant_unref0 (_tmp9_);
	block5_data_unref (_data5_);
	_data5_ = NULL;
	return self;
}


KeyEditorChildNullableBool* key_editor_child_nullable_bool_new (Key* key) {
	return key_editor_child_nullable_bool_construct (TYPE_KEY_EDITOR_CHILD_NULLABLE_BOOL, key);
}


static GVariant* key_editor_child_nullable_bool_real_get_variant (KeyEditorChild* base) {
	KeyEditorChildNullableBool * self;
	GVariant* result = NULL;
	GVariant* _tmp0_;
	GVariant* _tmp1_;
	self = (KeyEditorChildNullableBool*) base;
	_tmp0_ = self->priv->variant;
	_tmp1_ = _g_variant_ref0 (_tmp0_);
	result = _tmp1_;
	return result;
}


static void key_editor_child_nullable_bool_real_reload (KeyEditorChild* base, GVariant* gvariant) {
	KeyEditorChildNullableBool * self;
	GVariant* _tmp0_;
	GVariant* _tmp1_;
	GVariant* _tmp2_;
	GVariant* _tmp3_;
	GVariant* _tmp4_;
	GAction* _tmp11_;
	GVariantType* _tmp12_;
	GVariantType* _tmp13_;
	GVariant* _tmp14_;
	GVariant* _tmp15_;
	GVariant* _tmp16_;
	GVariant* _tmp17_;
	GVariant* _tmp18_;
	self = (KeyEditorChildNullableBool*) base;
	g_return_if_fail (gvariant != NULL);
	_tmp0_ = gvariant;
	_tmp1_ = _g_variant_ref0 (_tmp0_);
	_g_variant_unref0 (self->priv->variant);
	self->priv->variant = _tmp1_;
	_tmp2_ = self->priv->variant;
	_tmp3_ = g_variant_get_maybe (_tmp2_);
	_g_variant_unref0 (self->priv->maybe_variant);
	self->priv->maybe_variant = _tmp3_;
	_tmp4_ = self->priv->maybe_variant;
	if (_tmp4_ == NULL) {
		gchar* _tmp5_;
		gchar* _tmp6_;
		_tmp5_ = key_cool_boolean_text_value (NULL, TRUE);
		_tmp6_ = _tmp5_;
		gtk_button_set_label ((GtkButton*) self, _tmp6_);
		_g_free0 (_tmp6_);
	} else {
		GVariant* _tmp7_;
		gboolean _tmp8_;
		gchar* _tmp9_;
		gchar* _tmp10_;
		_tmp7_ = self->priv->maybe_variant;
		_tmp8_ = g_variant_get_boolean ((GVariant*) _tmp7_);
		_tmp9_ = key_cool_boolean_text_value (&_tmp8_, TRUE);
		_tmp10_ = _tmp9_;
		gtk_button_set_label ((GtkButton*) self, _tmp10_);
		_g_free0 (_tmp10_);
	}
	_tmp11_ = self->priv->action;
	_tmp12_ = g_variant_type_new ("mb");
	_tmp13_ = _tmp12_;
	_tmp14_ = gvariant;
	_tmp15_ = g_variant_new_maybe (_tmp13_, _tmp14_);
	g_variant_ref_sink (_tmp15_);
	_tmp16_ = _tmp15_;
	_tmp17_ = g_variant_new_maybe (NULL, _tmp16_);
	g_variant_ref_sink (_tmp17_);
	_tmp18_ = _tmp17_;
	g_action_change_state (_tmp11_, _tmp18_);
	_g_variant_unref0 (_tmp18_);
	_g_variant_unref0 (_tmp16_);
	_g_variant_type_free0 (_tmp13_);
}


static void key_editor_child_nullable_bool_class_init (KeyEditorChildNullableBoolClass * klass) {
	key_editor_child_nullable_bool_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (KeyEditorChildNullableBoolPrivate));
	G_OBJECT_CLASS (klass)->finalize = key_editor_child_nullable_bool_finalize;
}


static void key_editor_child_nullable_bool_key_editor_child_interface_init (KeyEditorChildIface * iface) {
	key_editor_child_nullable_bool_key_editor_child_parent_iface = g_type_interface_peek_parent (iface);
	iface->get_variant = (GVariant* (*) (KeyEditorChild *)) key_editor_child_nullable_bool_real_get_variant;
	iface->reload = (void (*) (KeyEditorChild *, GVariant*)) key_editor_child_nullable_bool_real_reload;
}


static void key_editor_child_nullable_bool_instance_init (KeyEditorChildNullableBool * self) {
	self->priv = KEY_EDITOR_CHILD_NULLABLE_BOOL_GET_PRIVATE (self);
}


static void key_editor_child_nullable_bool_finalize (GObject * obj) {
	KeyEditorChildNullableBool * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_KEY_EDITOR_CHILD_NULLABLE_BOOL, KeyEditorChildNullableBool);
	_g_variant_unref0 (self->priv->variant);
	_g_variant_unref0 (self->priv->maybe_variant);
	_g_object_unref0 (self->priv->action);
	G_OBJECT_CLASS (key_editor_child_nullable_bool_parent_class)->finalize (obj);
}


GType key_editor_child_nullable_bool_get_type (void) {
	static volatile gsize key_editor_child_nullable_bool_type_id__volatile = 0;
	if (g_once_init_enter (&key_editor_child_nullable_bool_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (KeyEditorChildNullableBoolClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) key_editor_child_nullable_bool_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (KeyEditorChildNullableBool), 0, (GInstanceInitFunc) key_editor_child_nullable_bool_instance_init, NULL };
		static const GInterfaceInfo key_editor_child_info = { (GInterfaceInitFunc) key_editor_child_nullable_bool_key_editor_child_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType key_editor_child_nullable_bool_type_id;
		key_editor_child_nullable_bool_type_id = g_type_register_static (gtk_menu_button_get_type (), "KeyEditorChildNullableBool", &g_define_type_info, 0);
		g_type_add_interface_static (key_editor_child_nullable_bool_type_id, TYPE_KEY_EDITOR_CHILD, &key_editor_child_info);
		g_once_init_leave (&key_editor_child_nullable_bool_type_id__volatile, key_editor_child_nullable_bool_type_id);
	}
	return key_editor_child_nullable_bool_type_id__volatile;
}


static void __lambda32_ (KeyEditorChildBool* self) {
	g_signal_emit ((KeyEditorChild*) self, key_editor_child_signals[KEY_EDITOR_CHILD_VALUE_HAS_CHANGED_SIGNAL], 0, TRUE);
}


static void ___lambda32__gtk_toggle_button_toggled (GtkToggleButton* _sender, gpointer self) {
	__lambda32_ ((KeyEditorChildBool*) self);
}


KeyEditorChildBool* key_editor_child_bool_construct (GType object_type, gboolean initial_value) {
	KeyEditorChildBool * self = NULL;
	GtkStyleContext* _tmp0_;
	GtkToggleButton* button_false = NULL;
	GtkToggleButton* _tmp1_;
	gboolean _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	GtkToggleButton* _tmp5_;
	GtkToggleButton* _tmp6_;
	GtkToggleButton* _tmp7_;
	gboolean _tmp8_;
	gchar* _tmp9_;
	gchar* _tmp10_;
	GtkToggleButton* _tmp11_;
	GtkToggleButton* _tmp12_;
	gboolean _tmp13_;
	GtkToggleButton* _tmp14_;
	GtkToggleButton* _tmp15_;
	self = (KeyEditorChildBool*) g_object_new (object_type, NULL);
	gtk_widget_set_visible ((GtkWidget*) self, TRUE);
	gtk_widget_set_hexpand ((GtkWidget*) self, TRUE);
	gtk_orientable_set_orientation ((GtkOrientable*) self, GTK_ORIENTATION_HORIZONTAL);
	gtk_widget_set_halign ((GtkWidget*) self, GTK_ALIGN_START);
	gtk_box_set_homogeneous ((GtkBox*) self, TRUE);
	g_object_set ((GtkWidget*) self, "width-request", 100, NULL);
	_tmp0_ = gtk_widget_get_style_context ((GtkWidget*) self);
	gtk_style_context_add_class (_tmp0_, "linked");
	_tmp1_ = (GtkToggleButton*) gtk_toggle_button_new ();
	g_object_ref_sink (_tmp1_);
	button_false = _tmp1_;
	gtk_widget_set_visible ((GtkWidget*) button_false, TRUE);
	_tmp2_ = FALSE;
	_tmp3_ = key_cool_boolean_text_value (&_tmp2_, TRUE);
	_tmp4_ = _tmp3_;
	gtk_button_set_label ((GtkButton*) button_false, _tmp4_);
	_g_free0 (_tmp4_);
	gtk_container_add ((GtkContainer*) self, (GtkWidget*) button_false);
	_tmp5_ = (GtkToggleButton*) gtk_toggle_button_new ();
	g_object_ref_sink (_tmp5_);
	_g_object_unref0 (self->priv->button_true);
	self->priv->button_true = _tmp5_;
	_tmp6_ = self->priv->button_true;
	gtk_widget_set_visible ((GtkWidget*) _tmp6_, TRUE);
	_tmp7_ = self->priv->button_true;
	_tmp8_ = TRUE;
	_tmp9_ = key_cool_boolean_text_value (&_tmp8_, TRUE);
	_tmp10_ = _tmp9_;
	gtk_button_set_label ((GtkButton*) _tmp7_, _tmp10_);
	_g_free0 (_tmp10_);
	_tmp11_ = self->priv->button_true;
	gtk_container_add ((GtkContainer*) self, (GtkWidget*) _tmp11_);
	_tmp12_ = self->priv->button_true;
	_tmp13_ = initial_value;
	gtk_toggle_button_set_active (_tmp12_, _tmp13_);
	_tmp14_ = self->priv->button_true;
	g_object_bind_property_with_closures ((GObject*) _tmp14_, "active", (GObject*) button_false, "active", (G_BINDING_INVERT_BOOLEAN | G_BINDING_SYNC_CREATE) | G_BINDING_BIDIRECTIONAL, (GClosure*) ((NULL == NULL) ? NULL : g_cclosure_new ((GCallback) NULL, NULL, (GClosureNotify) NULL)), (GClosure*) ((NULL == NULL) ? NULL : g_cclosure_new ((GCallback) NULL, NULL, (GClosureNotify) NULL)));
	_tmp15_ = self->priv->button_true;
	g_signal_connect_object (_tmp15_, "toggled", (GCallback) ___lambda32__gtk_toggle_button_toggled, self, 0);
	_g_object_unref0 (button_false);
	return self;
}


KeyEditorChildBool* key_editor_child_bool_new (gboolean initial_value) {
	return key_editor_child_bool_construct (TYPE_KEY_EDITOR_CHILD_BOOL, initial_value);
}


static GVariant* key_editor_child_bool_real_get_variant (KeyEditorChild* base) {
	KeyEditorChildBool * self;
	GVariant* result = NULL;
	GtkToggleButton* _tmp0_;
	gboolean _tmp1_;
	gboolean _tmp2_;
	GVariant* _tmp3_;
	self = (KeyEditorChildBool*) base;
	_tmp0_ = self->priv->button_true;
	_tmp1_ = gtk_toggle_button_get_active (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_variant_new_boolean (_tmp2_);
	g_variant_ref_sink (_tmp3_);
	result = _tmp3_;
	return result;
}


static void key_editor_child_bool_real_reload (KeyEditorChild* base, GVariant* gvariant) {
	KeyEditorChildBool * self;
	GtkToggleButton* _tmp0_;
	GVariant* _tmp1_;
	gboolean _tmp2_;
	self = (KeyEditorChildBool*) base;
	g_return_if_fail (gvariant != NULL);
	_tmp0_ = self->priv->button_true;
	_tmp1_ = gvariant;
	_tmp2_ = g_variant_get_boolean (_tmp1_);
	gtk_toggle_button_set_active (_tmp0_, _tmp2_);
}


static void key_editor_child_bool_class_init (KeyEditorChildBoolClass * klass) {
	key_editor_child_bool_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (KeyEditorChildBoolPrivate));
	G_OBJECT_CLASS (klass)->finalize = key_editor_child_bool_finalize;
}


static void key_editor_child_bool_key_editor_child_interface_init (KeyEditorChildIface * iface) {
	key_editor_child_bool_key_editor_child_parent_iface = g_type_interface_peek_parent (iface);
	iface->get_variant = (GVariant* (*) (KeyEditorChild *)) key_editor_child_bool_real_get_variant;
	iface->reload = (void (*) (KeyEditorChild *, GVariant*)) key_editor_child_bool_real_reload;
}


static void key_editor_child_bool_instance_init (KeyEditorChildBool * self) {
	self->priv = KEY_EDITOR_CHILD_BOOL_GET_PRIVATE (self);
}


static void key_editor_child_bool_finalize (GObject * obj) {
	KeyEditorChildBool * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_KEY_EDITOR_CHILD_BOOL, KeyEditorChildBool);
	_g_object_unref0 (self->priv->button_true);
	G_OBJECT_CLASS (key_editor_child_bool_parent_class)->finalize (obj);
}


GType key_editor_child_bool_get_type (void) {
	static volatile gsize key_editor_child_bool_type_id__volatile = 0;
	if (g_once_init_enter (&key_editor_child_bool_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (KeyEditorChildBoolClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) key_editor_child_bool_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (KeyEditorChildBool), 0, (GInstanceInitFunc) key_editor_child_bool_instance_init, NULL };
		static const GInterfaceInfo key_editor_child_info = { (GInterfaceInitFunc) key_editor_child_bool_key_editor_child_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType key_editor_child_bool_type_id;
		key_editor_child_bool_type_id = g_type_register_static (gtk_box_get_type (), "KeyEditorChildBool", &g_define_type_info, 0);
		g_type_add_interface_static (key_editor_child_bool_type_id, TYPE_KEY_EDITOR_CHILD, &key_editor_child_info);
		g_once_init_leave (&key_editor_child_bool_type_id__volatile, key_editor_child_bool_type_id);
	}
	return key_editor_child_bool_type_id__volatile;
}


static Block6Data* block6_data_ref (Block6Data* _data6_) {
	g_atomic_int_inc (&_data6_->_ref_count_);
	return _data6_;
}


static void block6_data_unref (void * _userdata_) {
	Block6Data* _data6_;
	_data6_ = (Block6Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data6_->_ref_count_)) {
		KeyEditorChildNumberDouble* self;
		self = _data6_->self;
		_g_object_unref0 (_data6_->ref_buffer);
		_g_object_unref0 (self);
		g_slice_free (Block6Data, _data6_);
	}
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void __lambda37_ (KeyEditorChildNumberDouble* self) {
	g_signal_emit ((KeyEditorChild*) self, key_editor_child_signals[KEY_EDITOR_CHILD_VALUE_HAS_CHANGED_SIGNAL], 0, TRUE);
}


static void ___lambda37__gtk_entry_buffer_deleted_text (GtkEntryBuffer* _sender, guint position, guint n_chars, gpointer self) {
	__lambda37_ ((KeyEditorChildNumberDouble*) self);
}


static void __lambda38_ (KeyEditorChildNumberDouble* self) {
	g_signal_emit ((KeyEditorChild*) self, key_editor_child_signals[KEY_EDITOR_CHILD_VALUE_HAS_CHANGED_SIGNAL], 0, TRUE);
}


static void ___lambda38__gtk_entry_buffer_inserted_text (GtkEntryBuffer* _sender, guint position, const gchar* chars, guint n_chars, gpointer self) {
	__lambda38_ ((KeyEditorChildNumberDouble*) self);
}


static void __lambda39_ (KeyEditorChildNumberDouble* self) {
	gtk_spin_button_update ((GtkSpinButton*) self);
	g_signal_emit ((KeyEditorChild*) self, key_editor_child_signals[KEY_EDITOR_CHILD_CHILD_ACTIVATED_SIGNAL], 0);
}


static void ___lambda39__gtk_entry_activate (GtkEntry* _sender, gpointer self) {
	__lambda39_ ((KeyEditorChildNumberDouble*) self);
}


static void __lambda40_ (Block6Data* _data6_) {
	KeyEditorChildNumberDouble* self;
	gulong _tmp0_;
	gulong _tmp1_;
	self = _data6_->self;
	_tmp0_ = self->priv->deleted_text_handler;
	g_signal_handler_disconnect ((GObject*) _data6_->ref_buffer, _tmp0_);
	_tmp1_ = self->priv->inserted_text_handler;
	g_signal_handler_disconnect ((GObject*) _data6_->ref_buffer, _tmp1_);
	g_signal_handler_disconnect ((GObject*) self, _data6_->entry_activate_handler);
}


static void ___lambda40__gtk_widget_destroy (GtkWidget* _sender, gpointer self) {
	__lambda40_ (self);
}


KeyEditorChildNumberDouble* key_editor_child_number_double_construct (GType object_type, Key* key) {
	KeyEditorChildNumberDouble * self = NULL;
	Key* _tmp0_;
	const gchar* _tmp1_;
	const gchar* _tmp2_;
	Block6Data* _data6_;
	gdouble min = 0.0;
	gdouble max = 0.0;
	gboolean _tmp3_ = FALSE;
	Key* _tmp4_;
	gdouble _tmp20_ = 0.0;
	gboolean _tmp21_ = FALSE;
	Key* _tmp22_;
	gboolean _tmp23_;
	gboolean _tmp24_;
	GtkAdjustment* adjustment = NULL;
	gdouble _tmp37_;
	gdouble _tmp38_;
	GtkAdjustment* _tmp39_;
	GtkEntryBuffer* _tmp40_;
	GtkEntryBuffer* _tmp41_;
	GtkEntryBuffer* _tmp42_;
	gulong _tmp43_;
	gulong _tmp44_;
	gulong _tmp45_;
	g_return_val_if_fail (key != NULL, NULL);
	_tmp0_ = key;
	_tmp1_ = key_get_type_string (_tmp0_);
	_tmp2_ = _tmp1_;
	_vala_return_val_if_fail (g_strcmp0 (_tmp2_, "d") == 0, "key.type_string == \"d\"", NULL);
	_data6_ = g_slice_new0 (Block6Data);
	_data6_->_ref_count_ = 1;
	self = (KeyEditorChildNumberDouble*) g_object_new (object_type, NULL);
	_data6_->self = g_object_ref (self);
	gtk_widget_set_visible ((GtkWidget*) self, TRUE);
	gtk_widget_set_hexpand ((GtkWidget*) self, TRUE);
	gtk_widget_set_halign ((GtkWidget*) self, GTK_ALIGN_START);
	_tmp4_ = key;
	if (G_TYPE_CHECK_INSTANCE_TYPE (_tmp4_, TYPE_GSETTINGS_KEY)) {
		Key* _tmp5_;
		const gchar* _tmp6_;
		const gchar* _tmp7_;
		_tmp5_ = key;
		_tmp6_ = gsettings_key_get_range_type (G_TYPE_CHECK_INSTANCE_CAST (_tmp5_, TYPE_GSETTINGS_KEY, GSettingsKey));
		_tmp7_ = _tmp6_;
		_tmp3_ = g_strcmp0 (_tmp7_, "range") == 0;
	} else {
		_tmp3_ = FALSE;
	}
	if (_tmp3_) {
		Key* _tmp8_;
		GVariant* _tmp9_;
		GVariant* _tmp10_;
		GVariant* _tmp11_;
		GVariant* _tmp12_;
		gdouble _tmp13_;
		Key* _tmp14_;
		GVariant* _tmp15_;
		GVariant* _tmp16_;
		GVariant* _tmp17_;
		GVariant* _tmp18_;
		gdouble _tmp19_;
		_tmp8_ = key;
		_tmp9_ = gsettings_key_get_range_content (G_TYPE_CHECK_INSTANCE_CAST (_tmp8_, TYPE_GSETTINGS_KEY, GSettingsKey));
		_tmp10_ = _tmp9_;
		_tmp11_ = g_variant_get_child_value (_tmp10_, (gsize) 0);
		_tmp12_ = _tmp11_;
		_tmp13_ = g_variant_get_double (_tmp12_);
		min = _tmp13_;
		_g_variant_unref0 (_tmp12_);
		_tmp14_ = key;
		_tmp15_ = gsettings_key_get_range_content (G_TYPE_CHECK_INSTANCE_CAST (_tmp14_, TYPE_GSETTINGS_KEY, GSettingsKey));
		_tmp16_ = _tmp15_;
		_tmp17_ = g_variant_get_child_value (_tmp16_, (gsize) 1);
		_tmp18_ = _tmp17_;
		_tmp19_ = g_variant_get_double (_tmp18_);
		max = _tmp19_;
		_g_variant_unref0 (_tmp18_);
	} else {
		min = DBL_MIN;
		max = DBL_MAX;
	}
	_tmp22_ = key;
	_tmp23_ = key_get_planned_change (_tmp22_);
	_tmp24_ = _tmp23_;
	if (_tmp24_) {
		Key* _tmp25_;
		GVariant* _tmp26_;
		GVariant* _tmp27_;
		_tmp25_ = key;
		_tmp26_ = key_get_planned_value (_tmp25_);
		_tmp27_ = _tmp26_;
		_tmp21_ = _tmp27_ != NULL;
	} else {
		_tmp21_ = FALSE;
	}
	if (_tmp21_) {
		Key* _tmp28_;
		GVariant* _tmp29_;
		GVariant* _tmp30_;
		gdouble _tmp31_;
		_tmp28_ = key;
		_tmp29_ = key_get_planned_value (_tmp28_);
		_tmp30_ = _tmp29_;
		_tmp31_ = g_variant_get_double ((GVariant*) _tmp30_);
		_tmp20_ = _tmp31_;
	} else {
		Key* _tmp32_;
		GVariant* _tmp33_;
		GVariant* _tmp34_;
		GVariant* _tmp35_;
		gdouble _tmp36_;
		_tmp32_ = key;
		_tmp33_ = key_get_value (_tmp32_);
		_tmp34_ = _tmp33_;
		_tmp35_ = _tmp34_;
		_tmp36_ = g_variant_get_double (_tmp35_);
		_tmp20_ = _tmp36_;
		_g_variant_unref0 (_tmp35_);
	}
	_tmp37_ = min;
	_tmp38_ = max;
	_tmp39_ = gtk_adjustment_new (_tmp20_, _tmp37_, _tmp38_, 0.01, 0.1, 0.0);
	g_object_ref_sink (_tmp39_);
	adjustment = _tmp39_;
	gtk_spin_button_configure ((GtkSpinButton*) self, adjustment, 0.01, (guint) 2);
	gtk_spin_button_set_update_policy ((GtkSpinButton*) self, GTK_UPDATE_IF_VALID);
	gtk_spin_button_set_snap_to_ticks ((GtkSpinButton*) self, FALSE);
	gtk_entry_set_input_purpose ((GtkEntry*) self, GTK_INPUT_PURPOSE_NUMBER);
	gtk_entry_set_width_chars ((GtkEntry*) self, 30);
	_tmp40_ = gtk_entry_get_buffer ((GtkEntry*) self);
	_tmp41_ = _tmp40_;
	_tmp42_ = _g_object_ref0 (_tmp41_);
	_data6_->ref_buffer = _tmp42_;
	_tmp43_ = g_signal_connect_object (_data6_->ref_buffer, "deleted-text", (GCallback) ___lambda37__gtk_entry_buffer_deleted_text, self, 0);
	self->priv->deleted_text_handler = _tmp43_;
	_tmp44_ = g_signal_connect_object (_data6_->ref_buffer, "inserted-text", (GCallback) ___lambda38__gtk_entry_buffer_inserted_text, self, 0);
	self->priv->inserted_text_handler = _tmp44_;
	_tmp45_ = g_signal_connect_object ((GtkEntry*) self, "activate", (GCallback) ___lambda39__gtk_entry_activate, self, 0);
	_data6_->entry_activate_handler = _tmp45_;
	g_signal_connect_data ((GtkWidget*) self, "destroy", (GCallback) ___lambda40__gtk_widget_destroy, block6_data_ref (_data6_), (GClosureNotify) block6_data_unref, 0);
	_g_object_unref0 (adjustment);
	block6_data_unref (_data6_);
	_data6_ = NULL;
	return self;
}


KeyEditorChildNumberDouble* key_editor_child_number_double_new (Key* key) {
	return key_editor_child_number_double_construct (TYPE_KEY_EDITOR_CHILD_NUMBER_DOUBLE, key);
}


static GVariant* key_editor_child_number_double_real_get_variant (KeyEditorChild* base) {
	KeyEditorChildNumberDouble * self;
	GVariant* result = NULL;
	gdouble _tmp0_;
	GVariant* _tmp1_;
	self = (KeyEditorChildNumberDouble*) base;
	_tmp0_ = gtk_spin_button_get_value ((GtkSpinButton*) self);
	_tmp1_ = g_variant_new_double (_tmp0_);
	g_variant_ref_sink (_tmp1_);
	result = _tmp1_;
	return result;
}


static void key_editor_child_number_double_set_lock (KeyEditorChildNumberDouble* self, gboolean state) {
	gulong _tmp0_;
	gulong _tmp1_;
	gboolean _tmp2_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->deleted_text_handler;
	_tmp1_ = self->priv->inserted_text_handler;
	_vala_return_if_fail ((_tmp0_ != ((gulong) 0)) && (_tmp1_ != ((gulong) 0)), "deleted_text_handler != 0 && inserted_text_handler != 0");
	_tmp2_ = state;
	if (_tmp2_) {
		GtkEntryBuffer* _tmp3_;
		GtkEntryBuffer* _tmp4_;
		gulong _tmp5_;
		GtkEntryBuffer* _tmp6_;
		GtkEntryBuffer* _tmp7_;
		gulong _tmp8_;
		_tmp3_ = gtk_entry_get_buffer ((GtkEntry*) self);
		_tmp4_ = _tmp3_;
		_tmp5_ = self->priv->deleted_text_handler;
		g_signal_handler_block (_tmp4_, _tmp5_);
		_tmp6_ = gtk_entry_get_buffer ((GtkEntry*) self);
		_tmp7_ = _tmp6_;
		_tmp8_ = self->priv->inserted_text_handler;
		g_signal_handler_block (_tmp7_, _tmp8_);
	} else {
		GtkEntryBuffer* _tmp9_;
		GtkEntryBuffer* _tmp10_;
		gulong _tmp11_;
		GtkEntryBuffer* _tmp12_;
		GtkEntryBuffer* _tmp13_;
		gulong _tmp14_;
		_tmp9_ = gtk_entry_get_buffer ((GtkEntry*) self);
		_tmp10_ = _tmp9_;
		_tmp11_ = self->priv->deleted_text_handler;
		g_signal_handler_unblock (_tmp10_, _tmp11_);
		_tmp12_ = gtk_entry_get_buffer ((GtkEntry*) self);
		_tmp13_ = _tmp12_;
		_tmp14_ = self->priv->inserted_text_handler;
		g_signal_handler_unblock (_tmp13_, _tmp14_);
	}
}


static void key_editor_child_number_double_real_reload (KeyEditorChild* base, GVariant* gvariant) {
	KeyEditorChildNumberDouble * self;
	GVariant* _tmp0_;
	gdouble _tmp1_;
	self = (KeyEditorChildNumberDouble*) base;
	g_return_if_fail (gvariant != NULL);
	key_editor_child_number_double_set_lock (self, TRUE);
	_tmp0_ = gvariant;
	_tmp1_ = g_variant_get_double (_tmp0_);
	gtk_spin_button_set_value ((GtkSpinButton*) self, _tmp1_);
	key_editor_child_number_double_set_lock (self, FALSE);
}


static void key_editor_child_number_double_class_init (KeyEditorChildNumberDoubleClass * klass) {
	key_editor_child_number_double_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (KeyEditorChildNumberDoublePrivate));
	G_OBJECT_CLASS (klass)->finalize = key_editor_child_number_double_finalize;
}


static void key_editor_child_number_double_key_editor_child_interface_init (KeyEditorChildIface * iface) {
	key_editor_child_number_double_key_editor_child_parent_iface = g_type_interface_peek_parent (iface);
	iface->get_variant = (GVariant* (*) (KeyEditorChild *)) key_editor_child_number_double_real_get_variant;
	iface->reload = (void (*) (KeyEditorChild *, GVariant*)) key_editor_child_number_double_real_reload;
}


static void key_editor_child_number_double_instance_init (KeyEditorChildNumberDouble * self) {
	self->priv = KEY_EDITOR_CHILD_NUMBER_DOUBLE_GET_PRIVATE (self);
	self->priv->deleted_text_handler = (gulong) 0;
	self->priv->inserted_text_handler = (gulong) 0;
}


static void key_editor_child_number_double_finalize (GObject * obj) {
	KeyEditorChildNumberDouble * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_KEY_EDITOR_CHILD_NUMBER_DOUBLE, KeyEditorChildNumberDouble);
	G_OBJECT_CLASS (key_editor_child_number_double_parent_class)->finalize (obj);
}


GType key_editor_child_number_double_get_type (void) {
	static volatile gsize key_editor_child_number_double_type_id__volatile = 0;
	if (g_once_init_enter (&key_editor_child_number_double_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (KeyEditorChildNumberDoubleClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) key_editor_child_number_double_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (KeyEditorChildNumberDouble), 0, (GInstanceInitFunc) key_editor_child_number_double_instance_init, NULL };
		static const GInterfaceInfo key_editor_child_info = { (GInterfaceInitFunc) key_editor_child_number_double_key_editor_child_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType key_editor_child_number_double_type_id;
		key_editor_child_number_double_type_id = g_type_register_static (gtk_spin_button_get_type (), "KeyEditorChildNumberDouble", &g_define_type_info, 0);
		g_type_add_interface_static (key_editor_child_number_double_type_id, TYPE_KEY_EDITOR_CHILD, &key_editor_child_info);
		g_once_init_leave (&key_editor_child_number_double_type_id__volatile, key_editor_child_number_double_type_id);
	}
	return key_editor_child_number_double_type_id__volatile;
}


static Block7Data* block7_data_ref (Block7Data* _data7_) {
	g_atomic_int_inc (&_data7_->_ref_count_);
	return _data7_;
}


static void block7_data_unref (void * _userdata_) {
	Block7Data* _data7_;
	_data7_ = (Block7Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data7_->_ref_count_)) {
		KeyEditorChildNumberInt* self;
		self = _data7_->self;
		_g_object_unref0 (_data7_->ref_buffer);
		_g_object_unref0 (self);
		g_slice_free (Block7Data, _data7_);
	}
}


static void __lambda33_ (KeyEditorChildNumberInt* self) {
	g_signal_emit ((KeyEditorChild*) self, key_editor_child_signals[KEY_EDITOR_CHILD_VALUE_HAS_CHANGED_SIGNAL], 0, TRUE);
}


static void ___lambda33__gtk_entry_buffer_deleted_text (GtkEntryBuffer* _sender, guint position, guint n_chars, gpointer self) {
	__lambda33_ ((KeyEditorChildNumberInt*) self);
}


static void __lambda34_ (KeyEditorChildNumberInt* self) {
	g_signal_emit ((KeyEditorChild*) self, key_editor_child_signals[KEY_EDITOR_CHILD_VALUE_HAS_CHANGED_SIGNAL], 0, TRUE);
}


static void ___lambda34__gtk_entry_buffer_inserted_text (GtkEntryBuffer* _sender, guint position, const gchar* chars, guint n_chars, gpointer self) {
	__lambda34_ ((KeyEditorChildNumberInt*) self);
}


static void __lambda35_ (KeyEditorChildNumberInt* self) {
	gtk_spin_button_update ((GtkSpinButton*) self);
	g_signal_emit ((KeyEditorChild*) self, key_editor_child_signals[KEY_EDITOR_CHILD_CHILD_ACTIVATED_SIGNAL], 0);
}


static void ___lambda35__gtk_entry_activate (GtkEntry* _sender, gpointer self) {
	__lambda35_ ((KeyEditorChildNumberInt*) self);
}


static void __lambda36_ (Block7Data* _data7_) {
	KeyEditorChildNumberInt* self;
	gulong _tmp0_;
	gulong _tmp1_;
	self = _data7_->self;
	_tmp0_ = self->priv->deleted_text_handler;
	g_signal_handler_disconnect ((GObject*) _data7_->ref_buffer, _tmp0_);
	_tmp1_ = self->priv->inserted_text_handler;
	g_signal_handler_disconnect ((GObject*) _data7_->ref_buffer, _tmp1_);
	g_signal_handler_disconnect ((GObject*) self, _data7_->entry_activate_handler);
}


static void ___lambda36__gtk_widget_destroy (GtkWidget* _sender, gpointer self) {
	__lambda36_ (self);
}


KeyEditorChildNumberInt* key_editor_child_number_int_construct (GType object_type, Key* key) {
	KeyEditorChildNumberInt * self = NULL;
	Key* _tmp0_;
	const gchar* _tmp1_;
	const gchar* _tmp2_;
	Key* _tmp3_;
	const gchar* _tmp4_;
	const gchar* _tmp5_;
	Key* _tmp6_;
	const gchar* _tmp7_;
	const gchar* _tmp8_;
	Key* _tmp9_;
	const gchar* _tmp10_;
	const gchar* _tmp11_;
	Key* _tmp12_;
	const gchar* _tmp13_;
	const gchar* _tmp14_;
	Key* _tmp15_;
	const gchar* _tmp16_;
	const gchar* _tmp17_;
	Block7Data* _data7_;
	Key* _tmp18_;
	const gchar* _tmp19_;
	const gchar* _tmp20_;
	gchar* _tmp21_;
	gdouble min = 0.0;
	gdouble max = 0.0;
	gboolean _tmp22_ = FALSE;
	Key* _tmp23_;
	GVariant* _tmp44_ = NULL;
	gboolean _tmp45_ = FALSE;
	Key* _tmp46_;
	gboolean _tmp47_;
	gboolean _tmp48_;
	GtkAdjustment* adjustment = NULL;
	gdouble _tmp59_;
	gdouble _tmp60_;
	gdouble _tmp61_;
	GtkAdjustment* _tmp62_;
	GtkEntryBuffer* _tmp63_;
	GtkEntryBuffer* _tmp64_;
	GtkEntryBuffer* _tmp65_;
	gulong _tmp66_;
	gulong _tmp67_;
	gulong _tmp68_;
	g_return_val_if_fail (key != NULL, NULL);
	_tmp0_ = key;
	_tmp1_ = key_get_type_string (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = key;
	_tmp4_ = key_get_type_string (_tmp3_);
	_tmp5_ = _tmp4_;
	_tmp6_ = key;
	_tmp7_ = key_get_type_string (_tmp6_);
	_tmp8_ = _tmp7_;
	_tmp9_ = key;
	_tmp10_ = key_get_type_string (_tmp9_);
	_tmp11_ = _tmp10_;
	_tmp12_ = key;
	_tmp13_ = key_get_type_string (_tmp12_);
	_tmp14_ = _tmp13_;
	_tmp15_ = key;
	_tmp16_ = key_get_type_string (_tmp15_);
	_tmp17_ = _tmp16_;
	_vala_return_val_if_fail ((((((g_strcmp0 (_tmp2_, "y") == 0) || (g_strcmp0 (_tmp5_, "n") == 0)) || (g_strcmp0 (_tmp8_, "q") == 0)) || (g_strcmp0 (_tmp11_, "i") == 0)) || (g_strcmp0 (_tmp14_, "u") == 0)) || (g_strcmp0 (_tmp17_, "h") == 0), "key.type_string == \"y\" || key.type_string == \"n\" || key.type_string == \"q\" || key.type_string == \"i\" || key.type_string == \"u\" || key.type_string == \"h\"", NULL);
	_data7_ = g_slice_new0 (Block7Data);
	_data7_->_ref_count_ = 1;
	self = (KeyEditorChildNumberInt*) g_object_new (object_type, NULL);
	_data7_->self = g_object_ref (self);
	_tmp18_ = key;
	_tmp19_ = key_get_type_string (_tmp18_);
	_tmp20_ = _tmp19_;
	_tmp21_ = g_strdup (_tmp20_);
	_g_free0 (self->priv->key_type);
	self->priv->key_type = _tmp21_;
	gtk_widget_set_visible ((GtkWidget*) self, TRUE);
	gtk_widget_set_hexpand ((GtkWidget*) self, TRUE);
	gtk_widget_set_halign ((GtkWidget*) self, GTK_ALIGN_START);
	_tmp23_ = key;
	if (G_TYPE_CHECK_INSTANCE_TYPE (_tmp23_, TYPE_GSETTINGS_KEY)) {
		Key* _tmp24_;
		const gchar* _tmp25_;
		const gchar* _tmp26_;
		_tmp24_ = key;
		_tmp25_ = gsettings_key_get_range_type (G_TYPE_CHECK_INSTANCE_CAST (_tmp24_, TYPE_GSETTINGS_KEY, GSettingsKey));
		_tmp26_ = _tmp25_;
		_tmp22_ = g_strcmp0 (_tmp26_, "range") == 0;
	} else {
		_tmp22_ = FALSE;
	}
	if (_tmp22_) {
		Key* _tmp27_;
		GVariant* _tmp28_;
		GVariant* _tmp29_;
		GVariant* _tmp30_;
		GVariant* _tmp31_;
		gdouble _tmp32_;
		Key* _tmp33_;
		GVariant* _tmp34_;
		GVariant* _tmp35_;
		GVariant* _tmp36_;
		GVariant* _tmp37_;
		gdouble _tmp38_;
		_tmp27_ = key;
		_tmp28_ = gsettings_key_get_range_content (G_TYPE_CHECK_INSTANCE_CAST (_tmp27_, TYPE_GSETTINGS_KEY, GSettingsKey));
		_tmp29_ = _tmp28_;
		_tmp30_ = g_variant_get_child_value (_tmp29_, (gsize) 0);
		_tmp31_ = _tmp30_;
		_tmp32_ = key_editor_child_number_int_get_variant_as_double (_tmp31_);
		min = _tmp32_;
		_g_variant_unref0 (_tmp31_);
		_tmp33_ = key;
		_tmp34_ = gsettings_key_get_range_content (G_TYPE_CHECK_INSTANCE_CAST (_tmp33_, TYPE_GSETTINGS_KEY, GSettingsKey));
		_tmp35_ = _tmp34_;
		_tmp36_ = g_variant_get_child_value (_tmp35_, (gsize) 1);
		_tmp37_ = _tmp36_;
		_tmp38_ = key_editor_child_number_int_get_variant_as_double (_tmp37_);
		max = _tmp38_;
		_g_variant_unref0 (_tmp37_);
	} else {
		Key* _tmp39_;
		const gchar* _tmp40_;
		const gchar* _tmp41_;
		gdouble _tmp42_ = 0.0;
		gdouble _tmp43_ = 0.0;
		_tmp39_ = key;
		_tmp40_ = key_get_type_string (_tmp39_);
		_tmp41_ = _tmp40_;
		key_editor_child_number_int_get_min_and_max_double (&_tmp42_, &_tmp43_, _tmp41_);
		min = _tmp42_;
		max = _tmp43_;
	}
	_tmp46_ = key;
	_tmp47_ = key_get_planned_change (_tmp46_);
	_tmp48_ = _tmp47_;
	if (_tmp48_) {
		Key* _tmp49_;
		GVariant* _tmp50_;
		GVariant* _tmp51_;
		_tmp49_ = key;
		_tmp50_ = key_get_planned_value (_tmp49_);
		_tmp51_ = _tmp50_;
		_tmp45_ = _tmp51_ != NULL;
	} else {
		_tmp45_ = FALSE;
	}
	if (_tmp45_) {
		Key* _tmp52_;
		GVariant* _tmp53_;
		GVariant* _tmp54_;
		GVariant* _tmp55_;
		_tmp52_ = key;
		_tmp53_ = key_get_planned_value (_tmp52_);
		_tmp54_ = _tmp53_;
		_tmp55_ = _g_variant_ref0 ((GVariant*) _tmp54_);
		_g_variant_unref0 (_tmp44_);
		_tmp44_ = _tmp55_;
	} else {
		Key* _tmp56_;
		GVariant* _tmp57_;
		GVariant* _tmp58_;
		_tmp56_ = key;
		_tmp57_ = key_get_value (_tmp56_);
		_tmp58_ = _tmp57_;
		_g_variant_unref0 (_tmp44_);
		_tmp44_ = _tmp58_;
	}
	_tmp59_ = key_editor_child_number_int_get_variant_as_double (_tmp44_);
	_tmp60_ = min;
	_tmp61_ = max;
	_tmp62_ = gtk_adjustment_new (_tmp59_, _tmp60_, _tmp61_, 1.0, 5.0, 0.0);
	g_object_ref_sink (_tmp62_);
	adjustment = _tmp62_;
	gtk_spin_button_configure ((GtkSpinButton*) self, adjustment, 1.0, (guint) 0);
	gtk_spin_button_set_update_policy ((GtkSpinButton*) self, GTK_UPDATE_IF_VALID);
	gtk_spin_button_set_snap_to_ticks ((GtkSpinButton*) self, TRUE);
	gtk_spin_button_set_numeric ((GtkSpinButton*) self, TRUE);
	gtk_entry_set_input_purpose ((GtkEntry*) self, GTK_INPUT_PURPOSE_NUMBER);
	gtk_entry_set_width_chars ((GtkEntry*) self, 30);
	_tmp63_ = gtk_entry_get_buffer ((GtkEntry*) self);
	_tmp64_ = _tmp63_;
	_tmp65_ = _g_object_ref0 (_tmp64_);
	_data7_->ref_buffer = _tmp65_;
	_tmp66_ = g_signal_connect_object (_data7_->ref_buffer, "deleted-text", (GCallback) ___lambda33__gtk_entry_buffer_deleted_text, self, 0);
	self->priv->deleted_text_handler = _tmp66_;
	_tmp67_ = g_signal_connect_object (_data7_->ref_buffer, "inserted-text", (GCallback) ___lambda34__gtk_entry_buffer_inserted_text, self, 0);
	self->priv->inserted_text_handler = _tmp67_;
	_tmp68_ = g_signal_connect_object ((GtkEntry*) self, "activate", (GCallback) ___lambda35__gtk_entry_activate, self, 0);
	_data7_->entry_activate_handler = _tmp68_;
	g_signal_connect_data ((GtkWidget*) self, "destroy", (GCallback) ___lambda36__gtk_widget_destroy, block7_data_ref (_data7_), (GClosureNotify) block7_data_unref, 0);
	_g_object_unref0 (adjustment);
	_g_variant_unref0 (_tmp44_);
	block7_data_unref (_data7_);
	_data7_ = NULL;
	return self;
}


KeyEditorChildNumberInt* key_editor_child_number_int_new (Key* key) {
	return key_editor_child_number_int_construct (TYPE_KEY_EDITOR_CHILD_NUMBER_INT, key);
}


static void key_editor_child_number_int_get_min_and_max_double (gdouble* min, gdouble* max, const gchar* variant_type) {
	gdouble _vala_min = 0.0;
	gdouble _vala_max = 0.0;
	const gchar* _tmp0_;
	const gchar* _tmp1_;
	GQuark _tmp3_ = 0U;
	static GQuark _tmp2_label0 = 0;
	static GQuark _tmp2_label1 = 0;
	static GQuark _tmp2_label2 = 0;
	static GQuark _tmp2_label3 = 0;
	static GQuark _tmp2_label4 = 0;
	static GQuark _tmp2_label5 = 0;
	g_return_if_fail (variant_type != NULL);
	_tmp0_ = variant_type;
	_tmp1_ = _tmp0_;
	_tmp3_ = (NULL == _tmp1_) ? 0 : g_quark_from_string (_tmp1_);
	if (_tmp3_ == ((0 != _tmp2_label0) ? _tmp2_label0 : (_tmp2_label0 = g_quark_from_static_string ("y")))) {
		switch (0) {
			default:
			{
				_vala_min = (gdouble) 0U;
				_vala_max = (gdouble) G_MAXUINT8;
				break;
			}
		}
	} else if (_tmp3_ == ((0 != _tmp2_label1) ? _tmp2_label1 : (_tmp2_label1 = g_quark_from_static_string ("n")))) {
		switch (0) {
			default:
			{
				_vala_min = (gdouble) G_MININT16;
				_vala_max = (gdouble) G_MAXINT16;
				break;
			}
		}
	} else if (_tmp3_ == ((0 != _tmp2_label2) ? _tmp2_label2 : (_tmp2_label2 = g_quark_from_static_string ("q")))) {
		switch (0) {
			default:
			{
				_vala_min = (gdouble) 0U;
				_vala_max = (gdouble) G_MAXUINT16;
				break;
			}
		}
	} else if (_tmp3_ == ((0 != _tmp2_label3) ? _tmp2_label3 : (_tmp2_label3 = g_quark_from_static_string ("i")))) {
		switch (0) {
			default:
			{
				_vala_min = (gdouble) G_MININT32;
				_vala_max = (gdouble) G_MAXINT32;
				break;
			}
		}
	} else if (_tmp3_ == ((0 != _tmp2_label4) ? _tmp2_label4 : (_tmp2_label4 = g_quark_from_static_string ("u")))) {
		switch (0) {
			default:
			{
				_vala_min = (gdouble) 0U;
				_vala_max = (gdouble) G_MAXUINT32;
				break;
			}
		}
	} else if (_tmp3_ == ((0 != _tmp2_label5) ? _tmp2_label5 : (_tmp2_label5 = g_quark_from_static_string ("h")))) {
		switch (0) {
			default:
			{
				_vala_min = (gdouble) G_MININT32;
				_vala_max = (gdouble) G_MAXINT32;
				break;
			}
		}
	} else {
		switch (0) {
			default:
			{
				g_assert_not_reached ();
			}
		}
	}
	if (min) {
		*min = _vala_min;
	}
	if (max) {
		*max = _vala_max;
	}
}


static gdouble key_editor_child_number_int_get_variant_as_double (GVariant* variant) {
	gdouble result = 0.0;
	GVariant* _tmp0_;
	GVariantClass _tmp1_;
	g_return_val_if_fail (variant != NULL, 0.0);
	_tmp0_ = variant;
	_tmp1_ = g_variant_classify (_tmp0_);
	switch (_tmp1_) {
		case G_VARIANT_CLASS_BYTE:
		{
			GVariant* _tmp2_;
			guint8 _tmp3_;
			_tmp2_ = variant;
			_tmp3_ = g_variant_get_byte (_tmp2_);
			result = (gdouble) _tmp3_;
			return result;
		}
		case G_VARIANT_CLASS_INT16:
		{
			GVariant* _tmp4_;
			gint16 _tmp5_;
			_tmp4_ = variant;
			_tmp5_ = g_variant_get_int16 (_tmp4_);
			result = (gdouble) _tmp5_;
			return result;
		}
		case G_VARIANT_CLASS_UINT16:
		{
			GVariant* _tmp6_;
			guint16 _tmp7_;
			_tmp6_ = variant;
			_tmp7_ = g_variant_get_uint16 (_tmp6_);
			result = (gdouble) _tmp7_;
			return result;
		}
		case G_VARIANT_CLASS_INT32:
		{
			GVariant* _tmp8_;
			gint32 _tmp9_;
			_tmp8_ = variant;
			_tmp9_ = g_variant_get_int32 (_tmp8_);
			result = (gdouble) _tmp9_;
			return result;
		}
		case G_VARIANT_CLASS_UINT32:
		{
			GVariant* _tmp10_;
			guint32 _tmp11_;
			_tmp10_ = variant;
			_tmp11_ = g_variant_get_uint32 (_tmp10_);
			result = (gdouble) _tmp11_;
			return result;
		}
		case G_VARIANT_CLASS_HANDLE:
		{
			GVariant* _tmp12_;
			gint32 _tmp13_;
			_tmp12_ = variant;
			_tmp13_ = g_variant_get_handle (_tmp12_);
			result = (gdouble) _tmp13_;
			return result;
		}
		default:
		{
			g_assert_not_reached ();
		}
	}
}


static GVariant* key_editor_child_number_int_real_get_variant (KeyEditorChild* base) {
	KeyEditorChildNumberInt * self;
	GVariant* result = NULL;
	const gchar* _tmp0_;
	const gchar* _tmp1_;
	GQuark _tmp3_ = 0U;
	static GQuark _tmp2_label0 = 0;
	static GQuark _tmp2_label1 = 0;
	static GQuark _tmp2_label2 = 0;
	static GQuark _tmp2_label3 = 0;
	static GQuark _tmp2_label4 = 0;
	static GQuark _tmp2_label5 = 0;
	self = (KeyEditorChildNumberInt*) base;
	_tmp0_ = self->priv->key_type;
	_tmp1_ = _tmp0_;
	_tmp3_ = (NULL == _tmp1_) ? 0 : g_quark_from_string (_tmp1_);
	if (_tmp3_ == ((0 != _tmp2_label0) ? _tmp2_label0 : (_tmp2_label0 = g_quark_from_static_string ("y")))) {
		switch (0) {
			default:
			{
				gint64 _tmp4_;
				GVariant* _tmp5_;
				_tmp4_ = key_editor_child_number_int_get_int64_from_entry (self);
				_tmp5_ = g_variant_new_byte ((guchar) _tmp4_);
				g_variant_ref_sink (_tmp5_);
				result = _tmp5_;
				return result;
			}
		}
	} else if (_tmp3_ == ((0 != _tmp2_label1) ? _tmp2_label1 : (_tmp2_label1 = g_quark_from_static_string ("n")))) {
		switch (0) {
			default:
			{
				gint64 _tmp6_;
				GVariant* _tmp7_;
				_tmp6_ = key_editor_child_number_int_get_int64_from_entry (self);
				_tmp7_ = g_variant_new_int16 ((gint16) _tmp6_);
				g_variant_ref_sink (_tmp7_);
				result = _tmp7_;
				return result;
			}
		}
	} else if (_tmp3_ == ((0 != _tmp2_label2) ? _tmp2_label2 : (_tmp2_label2 = g_quark_from_static_string ("q")))) {
		switch (0) {
			default:
			{
				gint64 _tmp8_;
				GVariant* _tmp9_;
				_tmp8_ = key_editor_child_number_int_get_int64_from_entry (self);
				_tmp9_ = g_variant_new_uint16 ((guint16) _tmp8_);
				g_variant_ref_sink (_tmp9_);
				result = _tmp9_;
				return result;
			}
		}
	} else if (_tmp3_ == ((0 != _tmp2_label3) ? _tmp2_label3 : (_tmp2_label3 = g_quark_from_static_string ("i")))) {
		switch (0) {
			default:
			{
				gint64 _tmp10_;
				GVariant* _tmp11_;
				_tmp10_ = key_editor_child_number_int_get_int64_from_entry (self);
				_tmp11_ = g_variant_new_int32 ((gint32) _tmp10_);
				g_variant_ref_sink (_tmp11_);
				result = _tmp11_;
				return result;
			}
		}
	} else if (_tmp3_ == ((0 != _tmp2_label4) ? _tmp2_label4 : (_tmp2_label4 = g_quark_from_static_string ("u")))) {
		switch (0) {
			default:
			{
				gint64 _tmp12_;
				GVariant* _tmp13_;
				_tmp12_ = key_editor_child_number_int_get_int64_from_entry (self);
				_tmp13_ = g_variant_new_uint32 ((guint32) _tmp12_);
				g_variant_ref_sink (_tmp13_);
				result = _tmp13_;
				return result;
			}
		}
	} else if (_tmp3_ == ((0 != _tmp2_label5) ? _tmp2_label5 : (_tmp2_label5 = g_quark_from_static_string ("h")))) {
		switch (0) {
			default:
			{
				gint64 _tmp14_;
				GVariant* _tmp15_;
				_tmp14_ = key_editor_child_number_int_get_int64_from_entry (self);
				_tmp15_ = g_variant_new_handle ((gint32) _tmp14_);
				g_variant_ref_sink (_tmp15_);
				result = _tmp15_;
				return result;
			}
		}
	} else {
		switch (0) {
			default:
			{
				g_assert_not_reached ();
			}
		}
	}
}


static gint64 int64_parse (const gchar* str) {
	gint64 result = 0LL;
	const gchar* _tmp0_;
	gint64 _tmp1_;
	g_return_val_if_fail (str != NULL, 0LL);
	_tmp0_ = str;
	_tmp1_ = g_ascii_strtoll (_tmp0_, NULL, (guint) 0);
	result = _tmp1_;
	return result;
}


static gint64 key_editor_child_number_int_get_int64_from_entry (KeyEditorChildNumberInt* self) {
	gint64 result = 0LL;
	const gchar* _tmp0_;
	gint64 _tmp1_;
	g_return_val_if_fail (self != NULL, 0LL);
	_tmp0_ = gtk_entry_get_text ((GtkEntry*) self);
	_tmp1_ = int64_parse (_tmp0_);
	result = _tmp1_;
	return result;
}


static void key_editor_child_number_int_set_lock (KeyEditorChildNumberInt* self, gboolean state) {
	gulong _tmp0_;
	gulong _tmp1_;
	gboolean _tmp2_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->deleted_text_handler;
	_tmp1_ = self->priv->inserted_text_handler;
	_vala_return_if_fail ((_tmp0_ != ((gulong) 0)) && (_tmp1_ != ((gulong) 0)), "deleted_text_handler != 0 && inserted_text_handler != 0");
	_tmp2_ = state;
	if (_tmp2_) {
		GtkEntryBuffer* _tmp3_;
		GtkEntryBuffer* _tmp4_;
		gulong _tmp5_;
		GtkEntryBuffer* _tmp6_;
		GtkEntryBuffer* _tmp7_;
		gulong _tmp8_;
		_tmp3_ = gtk_entry_get_buffer ((GtkEntry*) self);
		_tmp4_ = _tmp3_;
		_tmp5_ = self->priv->deleted_text_handler;
		g_signal_handler_block (_tmp4_, _tmp5_);
		_tmp6_ = gtk_entry_get_buffer ((GtkEntry*) self);
		_tmp7_ = _tmp6_;
		_tmp8_ = self->priv->inserted_text_handler;
		g_signal_handler_block (_tmp7_, _tmp8_);
	} else {
		GtkEntryBuffer* _tmp9_;
		GtkEntryBuffer* _tmp10_;
		gulong _tmp11_;
		GtkEntryBuffer* _tmp12_;
		GtkEntryBuffer* _tmp13_;
		gulong _tmp14_;
		_tmp9_ = gtk_entry_get_buffer ((GtkEntry*) self);
		_tmp10_ = _tmp9_;
		_tmp11_ = self->priv->deleted_text_handler;
		g_signal_handler_unblock (_tmp10_, _tmp11_);
		_tmp12_ = gtk_entry_get_buffer ((GtkEntry*) self);
		_tmp13_ = _tmp12_;
		_tmp14_ = self->priv->inserted_text_handler;
		g_signal_handler_unblock (_tmp13_, _tmp14_);
	}
}


static void key_editor_child_number_int_real_reload (KeyEditorChild* base, GVariant* gvariant) {
	KeyEditorChildNumberInt * self;
	GVariant* _tmp0_;
	gdouble _tmp1_;
	self = (KeyEditorChildNumberInt*) base;
	g_return_if_fail (gvariant != NULL);
	key_editor_child_number_int_set_lock (self, TRUE);
	_tmp0_ = gvariant;
	_tmp1_ = key_editor_child_number_int_get_variant_as_double (_tmp0_);
	gtk_spin_button_set_value ((GtkSpinButton*) self, _tmp1_);
	key_editor_child_number_int_set_lock (self, FALSE);
}


static void key_editor_child_number_int_class_init (KeyEditorChildNumberIntClass * klass) {
	key_editor_child_number_int_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (KeyEditorChildNumberIntPrivate));
	G_OBJECT_CLASS (klass)->finalize = key_editor_child_number_int_finalize;
}


static void key_editor_child_number_int_key_editor_child_interface_init (KeyEditorChildIface * iface) {
	key_editor_child_number_int_key_editor_child_parent_iface = g_type_interface_peek_parent (iface);
	iface->get_variant = (GVariant* (*) (KeyEditorChild *)) key_editor_child_number_int_real_get_variant;
	iface->reload = (void (*) (KeyEditorChild *, GVariant*)) key_editor_child_number_int_real_reload;
}


static void key_editor_child_number_int_instance_init (KeyEditorChildNumberInt * self) {
	self->priv = KEY_EDITOR_CHILD_NUMBER_INT_GET_PRIVATE (self);
	self->priv->deleted_text_handler = (gulong) 0;
	self->priv->inserted_text_handler = (gulong) 0;
}


static void key_editor_child_number_int_finalize (GObject * obj) {
	KeyEditorChildNumberInt * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_KEY_EDITOR_CHILD_NUMBER_INT, KeyEditorChildNumberInt);
	_g_free0 (self->priv->key_type);
	G_OBJECT_CLASS (key_editor_child_number_int_parent_class)->finalize (obj);
}


GType key_editor_child_number_int_get_type (void) {
	static volatile gsize key_editor_child_number_int_type_id__volatile = 0;
	if (g_once_init_enter (&key_editor_child_number_int_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (KeyEditorChildNumberIntClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) key_editor_child_number_int_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (KeyEditorChildNumberInt), 0, (GInstanceInitFunc) key_editor_child_number_int_instance_init, NULL };
		static const GInterfaceInfo key_editor_child_info = { (GInterfaceInitFunc) key_editor_child_number_int_key_editor_child_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType key_editor_child_number_int_type_id;
		key_editor_child_number_int_type_id = g_type_register_static (gtk_spin_button_get_type (), "KeyEditorChildNumberInt", &g_define_type_info, 0);
		g_type_add_interface_static (key_editor_child_number_int_type_id, TYPE_KEY_EDITOR_CHILD, &key_editor_child_info);
		g_once_init_leave (&key_editor_child_number_int_type_id__volatile, key_editor_child_number_int_type_id);
	}
	return key_editor_child_number_int_type_id__volatile;
}


static Block8Data* block8_data_ref (Block8Data* _data8_) {
	g_atomic_int_inc (&_data8_->_ref_count_);
	return _data8_;
}


static void block8_data_unref (void * _userdata_) {
	Block8Data* _data8_;
	_data8_ = (Block8Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data8_->_ref_count_)) {
		KeyEditorChildDefault* self;
		self = _data8_->self;
		_g_object_unref0 (_data8_->ref_buffer);
		_g_object_unref0 (self);
		g_slice_free (Block8Data, _data8_);
	}
}


static void __lambda42_ (KeyEditorChildDefault* self) {
	gboolean _tmp0_;
	_tmp0_ = key_editor_child_default_test_value (self);
	g_signal_emit ((KeyEditorChild*) self, key_editor_child_signals[KEY_EDITOR_CHILD_VALUE_HAS_CHANGED_SIGNAL], 0, _tmp0_);
}


static void ___lambda42__gtk_entry_buffer_deleted_text (GtkEntryBuffer* _sender, guint position, guint n_chars, gpointer self) {
	__lambda42_ ((KeyEditorChildDefault*) self);
}


static void __lambda43_ (KeyEditorChildDefault* self) {
	gboolean _tmp0_;
	_tmp0_ = key_editor_child_default_test_value (self);
	g_signal_emit ((KeyEditorChild*) self, key_editor_child_signals[KEY_EDITOR_CHILD_VALUE_HAS_CHANGED_SIGNAL], 0, _tmp0_);
}


static void ___lambda43__gtk_entry_buffer_inserted_text (GtkEntryBuffer* _sender, guint position, const gchar* chars, guint n_chars, gpointer self) {
	__lambda43_ ((KeyEditorChildDefault*) self);
}


static void __lambda44_ (KeyEditorChildDefault* self) {
	gboolean _tmp0_;
	_tmp0_ = key_editor_child_default_test_value (self);
	if (_tmp0_) {
		g_signal_emit ((KeyEditorChild*) self, key_editor_child_signals[KEY_EDITOR_CHILD_CHILD_ACTIVATED_SIGNAL], 0);
	}
}


static void ___lambda44__gtk_entry_activate (GtkEntry* _sender, gpointer self) {
	__lambda44_ ((KeyEditorChildDefault*) self);
}


static void __lambda45_ (Block8Data* _data8_) {
	KeyEditorChildDefault* self;
	gulong _tmp0_;
	gulong _tmp1_;
	self = _data8_->self;
	_tmp0_ = self->priv->deleted_text_handler;
	g_signal_handler_disconnect ((GObject*) _data8_->ref_buffer, _tmp0_);
	_tmp1_ = self->priv->inserted_text_handler;
	g_signal_handler_disconnect ((GObject*) _data8_->ref_buffer, _tmp1_);
	g_signal_handler_disconnect ((GObject*) self, _data8_->entry_activate_handler);
}


static void ___lambda45__gtk_widget_destroy (GtkWidget* _sender, gpointer self) {
	__lambda45_ (self);
}


KeyEditorChildDefault* key_editor_child_default_construct (GType object_type, const gchar* type, GVariant* initial_value) {
	KeyEditorChildDefault * self = NULL;
	Block8Data* _data8_;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	GVariant* _tmp2_;
	GVariant* _tmp3_;
	gboolean _tmp4_ = FALSE;
	gboolean _tmp5_ = FALSE;
	const gchar* _tmp6_;
	gchar* _tmp9_ = NULL;
	gboolean _tmp10_;
	GtkEntryBuffer* _tmp16_;
	GtkEntryBuffer* _tmp17_;
	GtkEntryBuffer* _tmp18_;
	gulong _tmp19_;
	gulong _tmp20_;
	gulong _tmp21_;
	g_return_val_if_fail (type != NULL, NULL);
	g_return_val_if_fail (initial_value != NULL, NULL);
	_data8_ = g_slice_new0 (Block8Data);
	_data8_->_ref_count_ = 1;
	self = (KeyEditorChildDefault*) g_object_new (object_type, NULL);
	_data8_->self = g_object_ref (self);
	_tmp0_ = type;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->variant_type);
	self->priv->variant_type = _tmp1_;
	_tmp2_ = initial_value;
	_tmp3_ = _g_variant_ref0 (_tmp2_);
	_g_variant_unref0 (self->priv->variant);
	self->priv->variant = _tmp3_;
	gtk_widget_set_visible ((GtkWidget*) self, TRUE);
	gtk_widget_set_hexpand ((GtkWidget*) self, TRUE);
	g_object_set ((GtkEntry*) self, "secondary-icon-activatable", FALSE, NULL);
	gtk_entry_set_icon_tooltip_text ((GtkEntry*) self, GTK_ENTRY_ICON_SECONDARY, _ ("This value is invalid for the key type."));
	_tmp6_ = type;
	if (g_strcmp0 (_tmp6_, "s") == 0) {
		_tmp5_ = TRUE;
	} else {
		const gchar* _tmp7_;
		_tmp7_ = type;
		_tmp5_ = g_strcmp0 (_tmp7_, "o") == 0;
	}
	if (_tmp5_) {
		_tmp4_ = TRUE;
	} else {
		const gchar* _tmp8_;
		_tmp8_ = type;
		_tmp4_ = g_strcmp0 (_tmp8_, "g") == 0;
	}
	self->priv->is_string = _tmp4_;
	_tmp10_ = self->priv->is_string;
	if (_tmp10_) {
		GVariant* _tmp11_;
		const gchar* _tmp12_;
		gchar* _tmp13_;
		_tmp11_ = initial_value;
		_tmp12_ = g_variant_get_string (_tmp11_, NULL);
		_tmp13_ = g_strdup (_tmp12_);
		_g_free0 (_tmp9_);
		_tmp9_ = _tmp13_;
	} else {
		GVariant* _tmp14_;
		gchar* _tmp15_;
		_tmp14_ = initial_value;
		_tmp15_ = g_variant_print (_tmp14_, FALSE);
		_g_free0 (_tmp9_);
		_tmp9_ = _tmp15_;
	}
	gtk_entry_set_text ((GtkEntry*) self, _tmp9_);
	_tmp16_ = gtk_entry_get_buffer ((GtkEntry*) self);
	_tmp17_ = _tmp16_;
	_tmp18_ = _g_object_ref0 (_tmp17_);
	_data8_->ref_buffer = _tmp18_;
	_tmp19_ = g_signal_connect_object (_data8_->ref_buffer, "deleted-text", (GCallback) ___lambda42__gtk_entry_buffer_deleted_text, self, 0);
	self->priv->deleted_text_handler = _tmp19_;
	_tmp20_ = g_signal_connect_object (_data8_->ref_buffer, "inserted-text", (GCallback) ___lambda43__gtk_entry_buffer_inserted_text, self, 0);
	self->priv->inserted_text_handler = _tmp20_;
	_tmp21_ = g_signal_connect_object ((GtkEntry*) self, "activate", (GCallback) ___lambda44__gtk_entry_activate, self, 0);
	_data8_->entry_activate_handler = _tmp21_;
	g_signal_connect_data ((GtkWidget*) self, "destroy", (GCallback) ___lambda45__gtk_widget_destroy, block8_data_ref (_data8_), (GClosureNotify) block8_data_unref, 0);
	_g_free0 (_tmp9_);
	block8_data_unref (_data8_);
	_data8_ = NULL;
	return self;
}


KeyEditorChildDefault* key_editor_child_default_new (const gchar* type, GVariant* initial_value) {
	return key_editor_child_default_construct (TYPE_KEY_EDITOR_CHILD_DEFAULT, type, initial_value);
}


static const gchar* string_to_string (const gchar* self) {
	const gchar* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = self;
	return result;
}


static gboolean key_editor_child_default_test_value (KeyEditorChildDefault* self) {
	gboolean result = FALSE;
	const gchar* _tmp0_;
	gchar* _tmp4_ = NULL;
	gboolean _tmp5_;
	gchar* tmp_text = NULL;
	gchar* _tmp13_;
	gboolean _tmp33_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->variant_type;
	if (g_strcmp0 (_tmp0_, "s") == 0) {
		const gchar* _tmp1_;
		const gchar* _tmp2_;
		GVariant* _tmp3_;
		_tmp1_ = gtk_entry_get_text ((GtkEntry*) self);
		_tmp2_ = _tmp1_;
		_tmp3_ = g_variant_new_string (_tmp2_);
		g_variant_ref_sink (_tmp3_);
		_g_variant_unref0 (self->priv->variant);
		self->priv->variant = _tmp3_;
		result = TRUE;
		return result;
	}
	_tmp5_ = self->priv->is_string;
	if (_tmp5_) {
		const gchar* _tmp6_;
		const gchar* _tmp7_;
		const gchar* _tmp8_;
		gchar* _tmp9_;
		_tmp6_ = gtk_entry_get_text ((GtkEntry*) self);
		_tmp7_ = _tmp6_;
		_tmp8_ = string_to_string (_tmp7_);
		_tmp9_ = g_strconcat ("'", _tmp8_, "'", NULL);
		_g_free0 (_tmp4_);
		_tmp4_ = _tmp9_;
	} else {
		const gchar* _tmp10_;
		const gchar* _tmp11_;
		gchar* _tmp12_;
		_tmp10_ = gtk_entry_get_text ((GtkEntry*) self);
		_tmp11_ = _tmp10_;
		_tmp12_ = g_strdup (_tmp11_);
		_g_free0 (_tmp4_);
		_tmp4_ = _tmp12_;
	}
	_tmp13_ = g_strdup (_tmp4_);
	tmp_text = _tmp13_;
	{
		GVariant* tmp_variant = NULL;
		const gchar* _tmp14_;
		GVariantType* _tmp15_;
		GVariantType* _tmp16_;
		const gchar* _tmp17_;
		GVariant* _tmp18_;
		GVariant* _tmp19_;
		GVariant* _tmp21_;
		GVariant* _tmp22_;
		GtkStyleContext* context = NULL;
		GtkStyleContext* _tmp23_;
		GtkStyleContext* _tmp24_;
		GtkStyleContext* _tmp25_;
		gboolean _tmp26_;
		_tmp14_ = self->priv->variant_type;
		_tmp15_ = g_variant_type_new (_tmp14_);
		_tmp16_ = _tmp15_;
		_tmp17_ = tmp_text;
		_tmp18_ = g_variant_parse (_tmp16_, _tmp17_, NULL, NULL, &_inner_error_);
		_tmp19_ = _tmp18_;
		_g_variant_type_free0 (_tmp16_);
		tmp_variant = _tmp19_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			gboolean _tmp20_ = FALSE;
			if (_inner_error_->domain == G_VARIANT_PARSE_ERROR) {
				goto __catch2_g_variant_parse_error;
			}
			_g_free0 (tmp_text);
			_g_free0 (_tmp4_);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return _tmp20_;
		}
		_tmp21_ = tmp_variant;
		_tmp22_ = _g_variant_ref0 ((GVariant*) _tmp21_);
		_g_variant_unref0 (self->priv->variant);
		self->priv->variant = _tmp22_;
		_tmp23_ = gtk_widget_get_style_context ((GtkWidget*) self);
		_tmp24_ = _g_object_ref0 (_tmp23_);
		context = _tmp24_;
		_tmp25_ = context;
		_tmp26_ = gtk_style_context_has_class (_tmp25_, "error");
		if (_tmp26_) {
			GtkStyleContext* _tmp27_;
			_tmp27_ = context;
			gtk_style_context_remove_class (_tmp27_, "error");
		}
		gtk_entry_set_icon_from_icon_name ((GtkEntry*) self, GTK_ENTRY_ICON_SECONDARY, NULL);
		result = TRUE;
		_g_object_unref0 (context);
		_g_variant_unref0 (tmp_variant);
		_g_free0 (tmp_text);
		_g_free0 (_tmp4_);
		return result;
	}
	goto __finally2;
	__catch2_g_variant_parse_error:
	{
		GError* e = NULL;
		GtkStyleContext* context = NULL;
		GtkStyleContext* _tmp28_;
		GtkStyleContext* _tmp29_;
		GtkStyleContext* _tmp30_;
		gboolean _tmp31_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp28_ = gtk_widget_get_style_context ((GtkWidget*) self);
		_tmp29_ = _g_object_ref0 (_tmp28_);
		context = _tmp29_;
		_tmp30_ = context;
		_tmp31_ = gtk_style_context_has_class (_tmp30_, "error");
		if (!_tmp31_) {
			GtkStyleContext* _tmp32_;
			_tmp32_ = context;
			gtk_style_context_add_class (_tmp32_, "error");
		}
		g_object_set ((GtkEntry*) self, "secondary-icon-name", "dialog-error-symbolic", NULL);
		result = FALSE;
		_g_object_unref0 (context);
		_g_error_free0 (e);
		_g_free0 (tmp_text);
		_g_free0 (_tmp4_);
		return result;
	}
	__finally2:
	_g_free0 (tmp_text);
	_g_free0 (_tmp4_);
	g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
	g_clear_error (&_inner_error_);
	return _tmp33_;
}


static GVariant* key_editor_child_default_real_get_variant (KeyEditorChild* base) {
	KeyEditorChildDefault * self;
	GVariant* result = NULL;
	GVariant* _tmp0_;
	GVariant* _tmp1_;
	self = (KeyEditorChildDefault*) base;
	_tmp0_ = self->priv->variant;
	_tmp1_ = _g_variant_ref0 (_tmp0_);
	result = _tmp1_;
	return result;
}


static void key_editor_child_default_set_lock (KeyEditorChildDefault* self, gboolean state) {
	gulong _tmp0_;
	gulong _tmp1_;
	gboolean _tmp2_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->deleted_text_handler;
	_tmp1_ = self->priv->inserted_text_handler;
	_vala_return_if_fail ((_tmp0_ != ((gulong) 0)) && (_tmp1_ != ((gulong) 0)), "deleted_text_handler != 0 && inserted_text_handler != 0");
	_tmp2_ = state;
	if (_tmp2_) {
		GtkEntryBuffer* _tmp3_;
		GtkEntryBuffer* _tmp4_;
		gulong _tmp5_;
		GtkEntryBuffer* _tmp6_;
		GtkEntryBuffer* _tmp7_;
		gulong _tmp8_;
		_tmp3_ = gtk_entry_get_buffer ((GtkEntry*) self);
		_tmp4_ = _tmp3_;
		_tmp5_ = self->priv->deleted_text_handler;
		g_signal_handler_block (_tmp4_, _tmp5_);
		_tmp6_ = gtk_entry_get_buffer ((GtkEntry*) self);
		_tmp7_ = _tmp6_;
		_tmp8_ = self->priv->inserted_text_handler;
		g_signal_handler_block (_tmp7_, _tmp8_);
	} else {
		GtkEntryBuffer* _tmp9_;
		GtkEntryBuffer* _tmp10_;
		gulong _tmp11_;
		GtkEntryBuffer* _tmp12_;
		GtkEntryBuffer* _tmp13_;
		gulong _tmp14_;
		_tmp9_ = gtk_entry_get_buffer ((GtkEntry*) self);
		_tmp10_ = _tmp9_;
		_tmp11_ = self->priv->deleted_text_handler;
		g_signal_handler_unblock (_tmp10_, _tmp11_);
		_tmp12_ = gtk_entry_get_buffer ((GtkEntry*) self);
		_tmp13_ = _tmp12_;
		_tmp14_ = self->priv->inserted_text_handler;
		g_signal_handler_unblock (_tmp13_, _tmp14_);
	}
}


static void key_editor_child_default_real_reload (KeyEditorChild* base, GVariant* gvariant) {
	KeyEditorChildDefault * self;
	gchar* _tmp0_ = NULL;
	gboolean _tmp1_;
	gboolean _tmp7_;
	self = (KeyEditorChildDefault*) base;
	g_return_if_fail (gvariant != NULL);
	key_editor_child_default_set_lock (self, TRUE);
	_tmp1_ = self->priv->is_string;
	if (_tmp1_) {
		GVariant* _tmp2_;
		const gchar* _tmp3_;
		gchar* _tmp4_;
		_tmp2_ = gvariant;
		_tmp3_ = g_variant_get_string (_tmp2_, NULL);
		_tmp4_ = g_strdup (_tmp3_);
		_g_free0 (_tmp0_);
		_tmp0_ = _tmp4_;
	} else {
		GVariant* _tmp5_;
		gchar* _tmp6_;
		_tmp5_ = gvariant;
		_tmp6_ = g_variant_print (_tmp5_, FALSE);
		_g_free0 (_tmp0_);
		_tmp0_ = _tmp6_;
	}
	gtk_entry_set_text ((GtkEntry*) self, _tmp0_);
	_tmp7_ = key_editor_child_default_test_value (self);
	if (!_tmp7_) {
		g_assert_not_reached ();
	}
	key_editor_child_default_set_lock (self, FALSE);
	_g_free0 (_tmp0_);
}


static void key_editor_child_default_class_init (KeyEditorChildDefaultClass * klass) {
	key_editor_child_default_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (KeyEditorChildDefaultPrivate));
	G_OBJECT_CLASS (klass)->finalize = key_editor_child_default_finalize;
}


static void key_editor_child_default_key_editor_child_interface_init (KeyEditorChildIface * iface) {
	key_editor_child_default_key_editor_child_parent_iface = g_type_interface_peek_parent (iface);
	iface->get_variant = (GVariant* (*) (KeyEditorChild *)) key_editor_child_default_real_get_variant;
	iface->reload = (void (*) (KeyEditorChild *, GVariant*)) key_editor_child_default_real_reload;
}


static void key_editor_child_default_instance_init (KeyEditorChildDefault * self) {
	self->priv = KEY_EDITOR_CHILD_DEFAULT_GET_PRIVATE (self);
	self->priv->deleted_text_handler = (gulong) 0;
	self->priv->inserted_text_handler = (gulong) 0;
}


static void key_editor_child_default_finalize (GObject * obj) {
	KeyEditorChildDefault * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_KEY_EDITOR_CHILD_DEFAULT, KeyEditorChildDefault);
	_g_free0 (self->priv->variant_type);
	_g_variant_unref0 (self->priv->variant);
	G_OBJECT_CLASS (key_editor_child_default_parent_class)->finalize (obj);
}


GType key_editor_child_default_get_type (void) {
	static volatile gsize key_editor_child_default_type_id__volatile = 0;
	if (g_once_init_enter (&key_editor_child_default_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (KeyEditorChildDefaultClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) key_editor_child_default_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (KeyEditorChildDefault), 0, (GInstanceInitFunc) key_editor_child_default_instance_init, NULL };
		static const GInterfaceInfo key_editor_child_info = { (GInterfaceInitFunc) key_editor_child_default_key_editor_child_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType key_editor_child_default_type_id;
		key_editor_child_default_type_id = g_type_register_static (gtk_entry_get_type (), "KeyEditorChildDefault", &g_define_type_info, 0);
		g_type_add_interface_static (key_editor_child_default_type_id, TYPE_KEY_EDITOR_CHILD, &key_editor_child_info);
		g_once_init_leave (&key_editor_child_default_type_id__volatile, key_editor_child_default_type_id);
	}
	return key_editor_child_default_type_id__volatile;
}



