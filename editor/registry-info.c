/* registry-info.c generated by valac 0.38.2.7-b777e, the Vala compiler
 * generated from registry-info.vala, do not modify */

/*
  This file is part of Dconf Editor

  Dconf Editor is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  Dconf Editor is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with Dconf Editor.  If not, see <http://www.gnu.org/licenses/>.
*/

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <stdlib.h>
#include <string.h>
#include <glib/gi18n-lib.h>
#include <float.h>
#include <math.h>


#define TYPE_REGISTRY_INFO (registry_info_get_type ())
#define REGISTRY_INFO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_REGISTRY_INFO, RegistryInfo))
#define REGISTRY_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_REGISTRY_INFO, RegistryInfoClass))
#define IS_REGISTRY_INFO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_REGISTRY_INFO))
#define IS_REGISTRY_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_REGISTRY_INFO))
#define REGISTRY_INFO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_REGISTRY_INFO, RegistryInfoClass))

typedef struct _RegistryInfo RegistryInfo;
typedef struct _RegistryInfoClass RegistryInfoClass;
typedef struct _RegistryInfoPrivate RegistryInfoPrivate;

#define TYPE_MODIFICATIONS_REVEALER (modifications_revealer_get_type ())
#define MODIFICATIONS_REVEALER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MODIFICATIONS_REVEALER, ModificationsRevealer))
#define MODIFICATIONS_REVEALER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MODIFICATIONS_REVEALER, ModificationsRevealerClass))
#define IS_MODIFICATIONS_REVEALER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MODIFICATIONS_REVEALER))
#define IS_MODIFICATIONS_REVEALER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MODIFICATIONS_REVEALER))
#define MODIFICATIONS_REVEALER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MODIFICATIONS_REVEALER, ModificationsRevealerClass))

typedef struct _ModificationsRevealer ModificationsRevealer;
typedef struct _ModificationsRevealerClass ModificationsRevealerClass;
enum  {
	REGISTRY_INFO_0_PROPERTY,
	REGISTRY_INFO_REVEALER_PROPERTY,
	REGISTRY_INFO_NUM_PROPERTIES
};
static GParamSpec* registry_info_properties[REGISTRY_INFO_NUM_PROPERTIES];
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define TYPE_SETTING_OBJECT (setting_object_get_type ())
#define SETTING_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SETTING_OBJECT, SettingObject))
#define SETTING_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SETTING_OBJECT, SettingObjectClass))
#define IS_SETTING_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SETTING_OBJECT))
#define IS_SETTING_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SETTING_OBJECT))
#define SETTING_OBJECT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SETTING_OBJECT, SettingObjectClass))

typedef struct _SettingObject SettingObject;
typedef struct _SettingObjectClass SettingObjectClass;

#define TYPE_KEY (key_get_type ())
#define KEY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_KEY, Key))
#define KEY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_KEY, KeyClass))
#define IS_KEY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_KEY))
#define IS_KEY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_KEY))
#define KEY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_KEY, KeyClass))

typedef struct _Key Key;
typedef struct _KeyClass KeyClass;

#define TYPE_KEY_EDITOR_CHILD (key_editor_child_get_type ())
#define KEY_EDITOR_CHILD(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_KEY_EDITOR_CHILD, KeyEditorChild))
#define IS_KEY_EDITOR_CHILD(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_KEY_EDITOR_CHILD))
#define KEY_EDITOR_CHILD_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_KEY_EDITOR_CHILD, KeyEditorChildIface))

typedef struct _KeyEditorChild KeyEditorChild;
typedef struct _KeyEditorChildIface KeyEditorChildIface;
typedef struct _Block19Data Block19Data;
#define _g_free0(var) (var = (g_free (var), NULL))

#define TYPE_DCONF_KEY (dconf_key_get_type ())
#define DCONF_KEY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_DCONF_KEY, DConfKey))
#define DCONF_KEY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_DCONF_KEY, DConfKeyClass))
#define IS_DCONF_KEY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_DCONF_KEY))
#define IS_DCONF_KEY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_DCONF_KEY))
#define DCONF_KEY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_DCONF_KEY, DConfKeyClass))

typedef struct _DConfKey DConfKey;
typedef struct _DConfKeyClass DConfKeyClass;
#define _g_variant_unref0(var) ((var == NULL) ? NULL : (var = (g_variant_unref (var), NULL)))

#define TYPE_GSETTINGS_KEY (gsettings_key_get_type ())
#define GSETTINGS_KEY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GSETTINGS_KEY, GSettingsKey))
#define GSETTINGS_KEY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GSETTINGS_KEY, GSettingsKeyClass))
#define IS_GSETTINGS_KEY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GSETTINGS_KEY))
#define IS_GSETTINGS_KEY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GSETTINGS_KEY))
#define GSETTINGS_KEY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GSETTINGS_KEY, GSettingsKeyClass))

typedef struct _GSettingsKey GSettingsKey;
typedef struct _GSettingsKeyClass GSettingsKeyClass;

#define TYPE_REGISTRY_VIEW (registry_view_get_type ())
#define REGISTRY_VIEW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_REGISTRY_VIEW, RegistryView))
#define REGISTRY_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_REGISTRY_VIEW, RegistryViewClass))
#define IS_REGISTRY_VIEW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_REGISTRY_VIEW))
#define IS_REGISTRY_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_REGISTRY_VIEW))
#define REGISTRY_VIEW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_REGISTRY_VIEW, RegistryViewClass))

typedef struct _RegistryView RegistryView;
typedef struct _RegistryViewClass RegistryViewClass;

#define TYPE_PATH_ELEMENT (path_element_get_type ())
#define PATH_ELEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PATH_ELEMENT, PathElement))
#define IS_PATH_ELEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PATH_ELEMENT))
#define PATH_ELEMENT_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_PATH_ELEMENT, PathElementIface))

typedef struct _PathElement PathElement;
typedef struct _PathElementIface PathElementIface;

#define TYPE_KEY_EDITOR_CHILD_SINGLE (key_editor_child_single_get_type ())
#define KEY_EDITOR_CHILD_SINGLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_KEY_EDITOR_CHILD_SINGLE, KeyEditorChildSingle))
#define KEY_EDITOR_CHILD_SINGLE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_KEY_EDITOR_CHILD_SINGLE, KeyEditorChildSingleClass))
#define IS_KEY_EDITOR_CHILD_SINGLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_KEY_EDITOR_CHILD_SINGLE))
#define IS_KEY_EDITOR_CHILD_SINGLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_KEY_EDITOR_CHILD_SINGLE))
#define KEY_EDITOR_CHILD_SINGLE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_KEY_EDITOR_CHILD_SINGLE, KeyEditorChildSingleClass))

typedef struct _KeyEditorChildSingle KeyEditorChildSingle;
typedef struct _KeyEditorChildSingleClass KeyEditorChildSingleClass;
typedef struct _Block20Data Block20Data;

#define TYPE_KEY_EDITOR_CHILD_ENUM (key_editor_child_enum_get_type ())
#define KEY_EDITOR_CHILD_ENUM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_KEY_EDITOR_CHILD_ENUM, KeyEditorChildEnum))
#define KEY_EDITOR_CHILD_ENUM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_KEY_EDITOR_CHILD_ENUM, KeyEditorChildEnumClass))
#define IS_KEY_EDITOR_CHILD_ENUM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_KEY_EDITOR_CHILD_ENUM))
#define IS_KEY_EDITOR_CHILD_ENUM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_KEY_EDITOR_CHILD_ENUM))
#define KEY_EDITOR_CHILD_ENUM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_KEY_EDITOR_CHILD_ENUM, KeyEditorChildEnumClass))

typedef struct _KeyEditorChildEnum KeyEditorChildEnum;
typedef struct _KeyEditorChildEnumClass KeyEditorChildEnumClass;

#define TYPE_KEY_EDITOR_CHILD_FLAGS (key_editor_child_flags_get_type ())
#define KEY_EDITOR_CHILD_FLAGS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_KEY_EDITOR_CHILD_FLAGS, KeyEditorChildFlags))
#define KEY_EDITOR_CHILD_FLAGS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_KEY_EDITOR_CHILD_FLAGS, KeyEditorChildFlagsClass))
#define IS_KEY_EDITOR_CHILD_FLAGS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_KEY_EDITOR_CHILD_FLAGS))
#define IS_KEY_EDITOR_CHILD_FLAGS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_KEY_EDITOR_CHILD_FLAGS))
#define KEY_EDITOR_CHILD_FLAGS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_KEY_EDITOR_CHILD_FLAGS, KeyEditorChildFlagsClass))

typedef struct _KeyEditorChildFlags KeyEditorChildFlags;
typedef struct _KeyEditorChildFlagsClass KeyEditorChildFlagsClass;

#define TYPE_KEY_EDITOR_CHILD_BOOL (key_editor_child_bool_get_type ())
#define KEY_EDITOR_CHILD_BOOL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_KEY_EDITOR_CHILD_BOOL, KeyEditorChildBool))
#define KEY_EDITOR_CHILD_BOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_KEY_EDITOR_CHILD_BOOL, KeyEditorChildBoolClass))
#define IS_KEY_EDITOR_CHILD_BOOL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_KEY_EDITOR_CHILD_BOOL))
#define IS_KEY_EDITOR_CHILD_BOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_KEY_EDITOR_CHILD_BOOL))
#define KEY_EDITOR_CHILD_BOOL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_KEY_EDITOR_CHILD_BOOL, KeyEditorChildBoolClass))

typedef struct _KeyEditorChildBool KeyEditorChildBool;
typedef struct _KeyEditorChildBoolClass KeyEditorChildBoolClass;

#define TYPE_KEY_EDITOR_CHILD_NUMBER_INT (key_editor_child_number_int_get_type ())
#define KEY_EDITOR_CHILD_NUMBER_INT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_KEY_EDITOR_CHILD_NUMBER_INT, KeyEditorChildNumberInt))
#define KEY_EDITOR_CHILD_NUMBER_INT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_KEY_EDITOR_CHILD_NUMBER_INT, KeyEditorChildNumberIntClass))
#define IS_KEY_EDITOR_CHILD_NUMBER_INT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_KEY_EDITOR_CHILD_NUMBER_INT))
#define IS_KEY_EDITOR_CHILD_NUMBER_INT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_KEY_EDITOR_CHILD_NUMBER_INT))
#define KEY_EDITOR_CHILD_NUMBER_INT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_KEY_EDITOR_CHILD_NUMBER_INT, KeyEditorChildNumberIntClass))

typedef struct _KeyEditorChildNumberInt KeyEditorChildNumberInt;
typedef struct _KeyEditorChildNumberIntClass KeyEditorChildNumberIntClass;

#define TYPE_KEY_EDITOR_CHILD_NUMBER_DOUBLE (key_editor_child_number_double_get_type ())
#define KEY_EDITOR_CHILD_NUMBER_DOUBLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_KEY_EDITOR_CHILD_NUMBER_DOUBLE, KeyEditorChildNumberDouble))
#define KEY_EDITOR_CHILD_NUMBER_DOUBLE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_KEY_EDITOR_CHILD_NUMBER_DOUBLE, KeyEditorChildNumberDoubleClass))
#define IS_KEY_EDITOR_CHILD_NUMBER_DOUBLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_KEY_EDITOR_CHILD_NUMBER_DOUBLE))
#define IS_KEY_EDITOR_CHILD_NUMBER_DOUBLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_KEY_EDITOR_CHILD_NUMBER_DOUBLE))
#define KEY_EDITOR_CHILD_NUMBER_DOUBLE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_KEY_EDITOR_CHILD_NUMBER_DOUBLE, KeyEditorChildNumberDoubleClass))

typedef struct _KeyEditorChildNumberDouble KeyEditorChildNumberDouble;
typedef struct _KeyEditorChildNumberDoubleClass KeyEditorChildNumberDoubleClass;

#define TYPE_KEY_EDITOR_CHILD_NULLABLE_BOOL (key_editor_child_nullable_bool_get_type ())
#define KEY_EDITOR_CHILD_NULLABLE_BOOL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_KEY_EDITOR_CHILD_NULLABLE_BOOL, KeyEditorChildNullableBool))
#define KEY_EDITOR_CHILD_NULLABLE_BOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_KEY_EDITOR_CHILD_NULLABLE_BOOL, KeyEditorChildNullableBoolClass))
#define IS_KEY_EDITOR_CHILD_NULLABLE_BOOL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_KEY_EDITOR_CHILD_NULLABLE_BOOL))
#define IS_KEY_EDITOR_CHILD_NULLABLE_BOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_KEY_EDITOR_CHILD_NULLABLE_BOOL))
#define KEY_EDITOR_CHILD_NULLABLE_BOOL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_KEY_EDITOR_CHILD_NULLABLE_BOOL, KeyEditorChildNullableBoolClass))

typedef struct _KeyEditorChildNullableBool KeyEditorChildNullableBool;
typedef struct _KeyEditorChildNullableBoolClass KeyEditorChildNullableBoolClass;

#define TYPE_KEY_EDITOR_CHILD_DEFAULT (key_editor_child_default_get_type ())
#define KEY_EDITOR_CHILD_DEFAULT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_KEY_EDITOR_CHILD_DEFAULT, KeyEditorChildDefault))
#define KEY_EDITOR_CHILD_DEFAULT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_KEY_EDITOR_CHILD_DEFAULT, KeyEditorChildDefaultClass))
#define IS_KEY_EDITOR_CHILD_DEFAULT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_KEY_EDITOR_CHILD_DEFAULT))
#define IS_KEY_EDITOR_CHILD_DEFAULT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_KEY_EDITOR_CHILD_DEFAULT))
#define KEY_EDITOR_CHILD_DEFAULT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_KEY_EDITOR_CHILD_DEFAULT, KeyEditorChildDefaultClass))

typedef struct _KeyEditorChildDefault KeyEditorChildDefault;
typedef struct _KeyEditorChildDefaultClass KeyEditorChildDefaultClass;

#define TYPE_PROPERTY_ROW (property_row_get_type ())
#define PROPERTY_ROW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PROPERTY_ROW, PropertyRow))
#define PROPERTY_ROW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PROPERTY_ROW, PropertyRowClass))
#define IS_PROPERTY_ROW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PROPERTY_ROW))
#define IS_PROPERTY_ROW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PROPERTY_ROW))
#define PROPERTY_ROW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PROPERTY_ROW, PropertyRowClass))

typedef struct _PropertyRow PropertyRow;
typedef struct _PropertyRowClass PropertyRowClass;
typedef struct _Block21Data Block21Data;
typedef struct _PropertyRowPrivate PropertyRowPrivate;
enum  {
	PROPERTY_ROW_0_PROPERTY,
	PROPERTY_ROW_NUM_PROPERTIES
};
static GParamSpec* property_row_properties[PROPERTY_ROW_NUM_PROPERTIES];

struct _RegistryInfo {
	GtkGrid parent_instance;
	RegistryInfoPrivate * priv;
};

struct _RegistryInfoClass {
	GtkGridClass parent_class;
};

struct _RegistryInfoPrivate {
	GtkRevealer* no_schema_warning;
	GtkRevealer* one_choice_warning_revealer;
	GtkLabel* one_choice_enum_warning;
	GtkLabel* one_choice_integer_warning;
	GtkListBox* properties_list_box;
	GtkButton* erase_button;
	ModificationsRevealer* _revealer;
	gulong erase_button_handler;
	gulong revealer_reload_1_handler;
	gulong revealer_reload_2_handler;
};

struct _KeyEditorChildIface {
	GTypeInterface parent_iface;
	GVariant* (*get_variant) (KeyEditorChild* self);
	void (*reload) (KeyEditorChild* self, GVariant* gvariant);
};

struct _Block19Data {
	int _ref_count_;
	RegistryInfo* self;
	gboolean has_schema;
	gchar* parent_path;
	gchar* tmp_string;
	GtkLabel* label;
	gulong key_value_changed_handler;
	KeyEditorChild* key_editor_child;
	gulong value_has_changed_handler;
	gulong child_activated_handler;
	Key* key;
};

struct _PathElementIface {
	GTypeInterface parent_iface;
};

struct _Block20Data {
	int _ref_count_;
	Block19Data * _data19_;
	GtkSwitch* custom_value_switch;
	GSettingsKey* gkey;
	gulong switch_active_handler;
};

struct _Block21Data {
	int _ref_count_;
	RegistryInfo* self;
	PropertyRow* row;
	gulong default_value_row_activate_handler;
	GtkSwitch* custom_value_switch;
};

struct _PropertyRow {
	GtkListBoxRow parent_instance;
	PropertyRowPrivate * priv;
};

struct _PropertyRowClass {
	GtkListBoxRowClass parent_class;
};

struct _PropertyRowPrivate {
	GtkGrid* grid;
	GtkLabel* name_label;
	GtkWidget* value_widget;
};


static gpointer registry_info_parent_class = NULL;
static gpointer property_row_parent_class = NULL;

GType registry_info_get_type (void) G_GNUC_CONST;
GType modifications_revealer_get_type (void) G_GNUC_CONST;
#define REGISTRY_INFO_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_REGISTRY_INFO, RegistryInfoPrivate))
void registry_info_clean (RegistryInfo* self);
static void registry_info_disconnect_handler (RegistryInfo* self, GtkWidget* widget, gulong* handler);
ModificationsRevealer* registry_info_get_revealer (RegistryInfo* self);
static void __lambda23_ (RegistryInfo* self, GtkWidget* widget);
static void ___lambda23__gtk_callback (GtkWidget* widget, gpointer self);
GType setting_object_get_type (void) G_GNUC_CONST;
GType key_get_type (void) G_GNUC_CONST;
void registry_info_populate_properties_list_box (RegistryInfo* self, Key* key);
GType key_editor_child_get_type (void) G_GNUC_CONST;
static Block19Data* block19_data_ref (Block19Data* _data19_);
static void block19_data_unref (void * _userdata_);
GType dconf_key_get_type (void) G_GNUC_CONST;
gboolean dconf_key_get_is_ghost (DConfKey* self);
GVariant* key_get_properties (Key* self);
static void __lambda24_ (RegistryInfo* self, GtkWidget* widget);
static void ___lambda24__gtk_callback (GtkWidget* widget, gpointer self);
static void registry_info_add_row_from_label (RegistryInfo* self, const gchar* property_name, const gchar* property_value);
GType gsettings_key_get_type (void) G_GNUC_CONST;
gboolean gsettings_key_get_is_default (GSettingsKey* self);
static gchar* registry_info_get_current_value_text (gboolean is_default, Key* key);
static void __lambda25_ (Block19Data* _data19_);
GtkWidget* _dconf_window_get_parent (GtkWidget* widget);
GType registry_view_get_type (void) G_GNUC_CONST;
GType path_element_get_type (void) G_GNUC_CONST;
static void ___lambda25__key_value_changed (Key* _sender, gpointer self);
static void registry_info_add_row_from_widget (RegistryInfo* self, const gchar* property_name, GtkWidget* widget, const gchar* type);
static void registry_info_add_separator (RegistryInfo* self);
static KeyEditorChild* registry_info_create_child (Key* key, gboolean has_schema);
GType key_editor_child_single_get_type (void) G_GNUC_CONST;
static void __lambda46_ (Block19Data* _data19_, gboolean is_valid);
gboolean modifications_revealer_should_delay_apply (ModificationsRevealer* self, const gchar* type_string);
void modifications_revealer_add_delayed_setting (ModificationsRevealer* self, Key* key, GVariant* new_value);
GVariant* key_editor_child_get_variant (KeyEditorChild* self);
void modifications_revealer_dismiss_change (ModificationsRevealer* self, Key* key);
void key_set_value (Key* self, GVariant* value);
static void ___lambda46__key_editor_child_value_has_changed (KeyEditorChild* _sender, gboolean is_valid, gpointer self);
static Block20Data* block20_data_ref (Block20Data* _data20_);
static void block20_data_unref (void * _userdata_);
static void registry_info_add_switch_row (RegistryInfo* self, const gchar* property_name, GtkSwitch* custom_value_switch);
gboolean key_get_planned_change (Key* self);
GVariant* key_get_planned_value (Key* self);
static void ___lambda49_ (Block20Data* _data20_);
GVariant* key_get_value (Key* self);
void key_editor_child_reload (KeyEditorChild* self, GVariant* gvariant);
void gsettings_key_set_to_default (GSettingsKey* self);
void key_set_planned_value (Key* self, GVariant* value);
static void ____lambda49__g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self);
static void ___lambda50_ (Block20Data* _data20_);
static void ____lambda50__modifications_revealer_reload (ModificationsRevealer* _sender, gpointer self);
static void ___lambda51_ (Block20Data* _data20_);
static void ____lambda51__gtk_widget_destroy (GtkWidget* _sender, gpointer self);
static void ___lambda52_ (Block19Data* _data19_);
void modifications_revealer_enter_delay_mode (ModificationsRevealer* self);
static void ____lambda52__gtk_button_clicked (GtkButton* _sender, gpointer self);
static void __lambda53_ (RegistryInfo* self);
void modifications_revealer_apply_delayed_settings (ModificationsRevealer* self);
static void ___lambda53__key_editor_child_child_activated (KeyEditorChild* _sender, gpointer self);
static void __lambda54_ (Block19Data* _data19_);
static void ___lambda54__modifications_revealer_reload (ModificationsRevealer* _sender, gpointer self);
static void __lambda55_ (Block19Data* _data19_);
static void ___lambda55__gtk_widget_destroy (GtkWidget* _sender, gpointer self);
const gchar* key_get_type_string (Key* self);
GVariant* gsettings_key_get_range_content (GSettingsKey* self);
KeyEditorChildSingle* key_editor_child_single_new (GVariant* key_value, const gchar* text);
KeyEditorChildSingle* key_editor_child_single_construct (GType object_type, GVariant* key_value, const gchar* text);
KeyEditorChildEnum* key_editor_child_enum_new (Key* key);
KeyEditorChildEnum* key_editor_child_enum_construct (GType object_type, Key* key);
GType key_editor_child_enum_get_type (void) G_GNUC_CONST;
KeyEditorChildFlags* key_editor_child_flags_new (GSettingsKey* key);
KeyEditorChildFlags* key_editor_child_flags_construct (GType object_type, GSettingsKey* key);
GType key_editor_child_flags_get_type (void) G_GNUC_CONST;
KeyEditorChildBool* key_editor_child_bool_new (gboolean initial_value);
KeyEditorChildBool* key_editor_child_bool_construct (GType object_type, gboolean initial_value);
GType key_editor_child_bool_get_type (void) G_GNUC_CONST;
const gchar* gsettings_key_get_range_type (GSettingsKey* self);
gint64 key_get_variant_as_int64 (GVariant* variant);
KeyEditorChildNumberInt* key_editor_child_number_int_new (Key* key);
KeyEditorChildNumberInt* key_editor_child_number_int_construct (GType object_type, Key* key);
GType key_editor_child_number_int_get_type (void) G_GNUC_CONST;
guint64 key_get_variant_as_uint64 (GVariant* variant);
KeyEditorChildNumberDouble* key_editor_child_number_double_new (Key* key);
KeyEditorChildNumberDouble* key_editor_child_number_double_construct (GType object_type, Key* key);
GType key_editor_child_number_double_get_type (void) G_GNUC_CONST;
KeyEditorChildNullableBool* key_editor_child_nullable_bool_new (Key* key);
KeyEditorChildNullableBool* key_editor_child_nullable_bool_construct (GType object_type, Key* key);
GType key_editor_child_nullable_bool_get_type (void) G_GNUC_CONST;
KeyEditorChildDefault* key_editor_child_default_new (const gchar* type, GVariant* initial_value);
KeyEditorChildDefault* key_editor_child_default_construct (GType object_type, const gchar* type, GVariant* initial_value);
GType key_editor_child_default_get_type (void) G_GNUC_CONST;
gchar* key_cool_text_value_from_variant (GVariant* variant, const gchar* type);
gchar* registry_info_get_copy_text (RegistryInfo* self);
GType property_row_get_type (void) G_GNUC_CONST;
gchar* property_row_get_copy_text (PropertyRow* self);
PropertyRow* property_row_new_from_label (const gchar* property_name, const gchar* property_value);
PropertyRow* property_row_construct_from_label (GType object_type, const gchar* property_name, const gchar* property_value);
static Block21Data* block21_data_ref (Block21Data* _data21_);
static void block21_data_unref (void * _userdata_);
PropertyRow* property_row_new_from_widgets (const gchar* property_name, GtkWidget* widget, GtkWidget* warning);
PropertyRow* property_row_construct_from_widgets (GType object_type, const gchar* property_name, GtkWidget* widget, GtkWidget* warning);
static void __lambda47_ (Block21Data* _data21_);
static void ___lambda47__gtk_list_box_row_activate (GtkListBoxRow* _sender, gpointer self);
static void __lambda48_ (Block21Data* _data21_);
static void ___lambda48__gtk_widget_destroy (GtkWidget* _sender, gpointer self);
static GtkWidget* registry_info_add_warning (const gchar* type);
static GtkWidget* registry_info_warning_label (const gchar* text);
RegistryInfo* registry_info_new (void);
RegistryInfo* registry_info_construct (GType object_type);
void registry_info_set_revealer (RegistryInfo* self, ModificationsRevealer* value);
static void registry_info_finalize (GObject * obj);
static void _vala_registry_info_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_registry_info_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
#define PROPERTY_ROW_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_PROPERTY_ROW, PropertyRowPrivate))
PropertyRow* property_row_new (void);
PropertyRow* property_row_construct (GType object_type);
static void property_row_finalize (GObject * obj);


static void __lambda23_ (RegistryInfo* self, GtkWidget* widget) {
	GtkWidget* _tmp0_;
	g_return_if_fail (widget != NULL);
	_tmp0_ = widget;
	gtk_widget_destroy (_tmp0_);
}


static void ___lambda23__gtk_callback (GtkWidget* widget, gpointer self) {
	__lambda23_ ((RegistryInfo*) self, widget);
}


void registry_info_clean (RegistryInfo* self) {
	GtkButton* _tmp0_;
	ModificationsRevealer* _tmp1_;
	ModificationsRevealer* _tmp2_;
	GtkListBox* _tmp3_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->erase_button;
	registry_info_disconnect_handler (self, (GtkWidget*) _tmp0_, &self->priv->erase_button_handler);
	_tmp1_ = self->priv->_revealer;
	registry_info_disconnect_handler (self, (GtkWidget*) _tmp1_, &self->priv->revealer_reload_1_handler);
	_tmp2_ = self->priv->_revealer;
	registry_info_disconnect_handler (self, (GtkWidget*) _tmp2_, &self->priv->revealer_reload_2_handler);
	_tmp3_ = self->priv->properties_list_box;
	gtk_container_foreach ((GtkContainer*) _tmp3_, ___lambda23__gtk_callback, self);
}


static void registry_info_disconnect_handler (RegistryInfo* self, GtkWidget* widget, gulong* handler) {
	gulong _tmp0_;
	GtkWidget* _tmp1_;
	gulong _tmp2_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (widget != NULL);
	_tmp0_ = *handler;
	if (_tmp0_ == ((gulong) 0)) {
		return;
	}
	_tmp1_ = widget;
	_tmp2_ = *handler;
	g_signal_handler_disconnect ((GObject*) _tmp1_, _tmp2_);
	*handler = (gulong) 0;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static Block19Data* block19_data_ref (Block19Data* _data19_) {
	g_atomic_int_inc (&_data19_->_ref_count_);
	return _data19_;
}


static void block19_data_unref (void * _userdata_) {
	Block19Data* _data19_;
	_data19_ = (Block19Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data19_->_ref_count_)) {
		RegistryInfo* self;
		self = _data19_->self;
		_g_object_unref0 (_data19_->key_editor_child);
		_g_object_unref0 (_data19_->label);
		_g_free0 (_data19_->tmp_string);
		_g_free0 (_data19_->parent_path);
		_g_object_unref0 (_data19_->key);
		_g_object_unref0 (self);
		g_slice_free (Block19Data, _data19_);
	}
}


static void __lambda24_ (RegistryInfo* self, GtkWidget* widget) {
	GtkWidget* _tmp0_;
	g_return_if_fail (widget != NULL);
	_tmp0_ = widget;
	gtk_widget_destroy (_tmp0_);
}


static void ___lambda24__gtk_callback (GtkWidget* widget, gpointer self) {
	__lambda24_ ((RegistryInfo*) self, widget);
}


static gpointer _g_variant_ref0 (gpointer self) {
	return self ? g_variant_ref (self) : NULL;
}


static void __lambda25_ (Block19Data* _data19_) {
	RegistryInfo* self;
	gboolean _tmp0_ = FALSE;
	self = _data19_->self;
	if (!_data19_->has_schema) {
		Key* _tmp1_;
		gboolean _tmp2_;
		gboolean _tmp3_;
		_tmp1_ = _data19_->key;
		_tmp2_ = dconf_key_get_is_ghost (G_TYPE_CHECK_INSTANCE_CAST (_tmp1_, TYPE_DCONF_KEY, DConfKey));
		_tmp3_ = _tmp2_;
		_tmp0_ = _tmp3_;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		GtkWidget* _tmp4_;
		GtkWidget* _tmp5_;
		GtkWidget* _tmp6_;
		RegistryView* _tmp7_;
		_tmp4_ = _dconf_window_get_parent ((GtkWidget*) self);
		_tmp5_ = _tmp4_;
		_tmp6_ = _dconf_window_get_parent (_tmp5_);
		_tmp7_ = G_TYPE_CHECK_INSTANCE_CAST (_tmp6_, TYPE_REGISTRY_VIEW, RegistryView);
		g_signal_emit_by_name ((PathElement*) _tmp7_, "request-path", _data19_->parent_path);
		_g_object_unref0 (_tmp7_);
		_g_object_unref0 (_tmp5_);
	} else {
		gboolean _tmp8_ = FALSE;
		GtkLabel* _tmp12_;
		Key* _tmp13_;
		gchar* _tmp14_;
		gchar* _tmp15_;
		if (_data19_->has_schema) {
			Key* _tmp9_;
			gboolean _tmp10_;
			gboolean _tmp11_;
			_tmp9_ = _data19_->key;
			_tmp10_ = gsettings_key_get_is_default (G_TYPE_CHECK_INSTANCE_CAST (_tmp9_, TYPE_GSETTINGS_KEY, GSettingsKey));
			_tmp11_ = _tmp10_;
			_tmp8_ = _tmp11_;
		} else {
			_tmp8_ = FALSE;
		}
		_tmp12_ = _data19_->label;
		_tmp13_ = _data19_->key;
		_tmp14_ = registry_info_get_current_value_text (_tmp8_, _tmp13_);
		_tmp15_ = _tmp14_;
		gtk_label_set_text (_tmp12_, _tmp15_);
		_g_free0 (_tmp15_);
	}
}


static void ___lambda25__key_value_changed (Key* _sender, gpointer self) {
	__lambda25_ (self);
}


static void __lambda46_ (Block19Data* _data19_, gboolean is_valid) {
	RegistryInfo* self;
	ModificationsRevealer* _tmp0_;
	const gchar* _tmp1_;
	gboolean _tmp2_;
	self = _data19_->self;
	_tmp0_ = self->priv->_revealer;
	_tmp1_ = _data19_->tmp_string;
	_tmp2_ = modifications_revealer_should_delay_apply (_tmp0_, _tmp1_);
	if (_tmp2_) {
		gboolean _tmp3_;
		_tmp3_ = is_valid;
		if (_tmp3_) {
			ModificationsRevealer* _tmp4_;
			Key* _tmp5_;
			KeyEditorChild* _tmp6_;
			GVariant* _tmp7_;
			GVariant* _tmp8_;
			_tmp4_ = self->priv->_revealer;
			_tmp5_ = _data19_->key;
			_tmp6_ = _data19_->key_editor_child;
			_tmp7_ = key_editor_child_get_variant (_tmp6_);
			_tmp8_ = _tmp7_;
			modifications_revealer_add_delayed_setting (_tmp4_, _tmp5_, _tmp8_);
			_g_variant_unref0 (_tmp8_);
		} else {
			ModificationsRevealer* _tmp9_;
			Key* _tmp10_;
			_tmp9_ = self->priv->_revealer;
			_tmp10_ = _data19_->key;
			modifications_revealer_dismiss_change (_tmp9_, _tmp10_);
		}
	} else {
		Key* _tmp11_;
		KeyEditorChild* _tmp12_;
		GVariant* _tmp13_;
		GVariant* _tmp14_;
		_tmp11_ = _data19_->key;
		_tmp12_ = _data19_->key_editor_child;
		_tmp13_ = key_editor_child_get_variant (_tmp12_);
		_tmp14_ = _tmp13_;
		key_set_value (_tmp11_, _tmp14_);
		_g_variant_unref0 (_tmp14_);
	}
}


static void ___lambda46__key_editor_child_value_has_changed (KeyEditorChild* _sender, gboolean is_valid, gpointer self) {
	__lambda46_ (self, is_valid);
}


static Block20Data* block20_data_ref (Block20Data* _data20_) {
	g_atomic_int_inc (&_data20_->_ref_count_);
	return _data20_;
}


static void block20_data_unref (void * _userdata_) {
	Block20Data* _data20_;
	_data20_ = (Block20Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data20_->_ref_count_)) {
		RegistryInfo* self;
		self = _data20_->_data19_->self;
		_g_object_unref0 (_data20_->gkey);
		_g_object_unref0 (_data20_->custom_value_switch);
		block19_data_unref (_data20_->_data19_);
		_data20_->_data19_ = NULL;
		g_slice_free (Block20Data, _data20_);
	}
}


static void ___lambda49_ (Block20Data* _data20_) {
	Block19Data* _data19_;
	RegistryInfo* self;
	ModificationsRevealer* _tmp0_;
	const gchar* _tmp1_;
	gboolean _tmp2_;
	_data19_ = _data20_->_data19_;
	self = _data19_->self;
	_tmp0_ = self->priv->_revealer;
	_tmp1_ = _data19_->tmp_string;
	_tmp2_ = modifications_revealer_should_delay_apply (_tmp0_, _tmp1_);
	if (_tmp2_) {
		GtkSwitch* _tmp3_;
		gboolean _tmp4_;
		_tmp3_ = _data20_->custom_value_switch;
		_tmp4_ = gtk_switch_get_active (_tmp3_);
		if (_tmp4_) {
			ModificationsRevealer* _tmp5_;
			Key* _tmp6_;
			_tmp5_ = self->priv->_revealer;
			_tmp6_ = _data19_->key;
			modifications_revealer_add_delayed_setting (_tmp5_, _tmp6_, NULL);
		} else {
			GVariant* _tmp7_ = NULL;
			gboolean _tmp8_ = FALSE;
			Key* _tmp9_;
			gboolean _tmp10_;
			gboolean _tmp11_;
			GVariant* tmp_variant = NULL;
			GVariant* _tmp22_;
			ModificationsRevealer* _tmp23_;
			Key* _tmp24_;
			GVariant* _tmp25_;
			KeyEditorChild* _tmp26_;
			GVariant* _tmp27_;
			_tmp9_ = _data19_->key;
			_tmp10_ = key_get_planned_change (_tmp9_);
			_tmp11_ = _tmp10_;
			if (_tmp11_) {
				Key* _tmp12_;
				GVariant* _tmp13_;
				GVariant* _tmp14_;
				_tmp12_ = _data19_->key;
				_tmp13_ = key_get_planned_value (_tmp12_);
				_tmp14_ = _tmp13_;
				_tmp8_ = _tmp14_ != NULL;
			} else {
				_tmp8_ = FALSE;
			}
			if (_tmp8_) {
				Key* _tmp15_;
				GVariant* _tmp16_;
				GVariant* _tmp17_;
				GVariant* _tmp18_;
				_tmp15_ = _data19_->key;
				_tmp16_ = key_get_planned_value (_tmp15_);
				_tmp17_ = _tmp16_;
				_tmp18_ = _g_variant_ref0 ((GVariant*) _tmp17_);
				_g_variant_unref0 (_tmp7_);
				_tmp7_ = _tmp18_;
			} else {
				Key* _tmp19_;
				GVariant* _tmp20_;
				GVariant* _tmp21_;
				_tmp19_ = _data19_->key;
				_tmp20_ = key_get_value (_tmp19_);
				_tmp21_ = _tmp20_;
				_g_variant_unref0 (_tmp7_);
				_tmp7_ = _tmp21_;
			}
			_tmp22_ = _g_variant_ref0 (_tmp7_);
			tmp_variant = _tmp22_;
			_tmp23_ = self->priv->_revealer;
			_tmp24_ = _data19_->key;
			_tmp25_ = tmp_variant;
			modifications_revealer_add_delayed_setting (_tmp23_, _tmp24_, _tmp25_);
			_tmp26_ = _data19_->key_editor_child;
			_tmp27_ = tmp_variant;
			key_editor_child_reload (_tmp26_, _tmp27_);
			_g_variant_unref0 (tmp_variant);
			_g_variant_unref0 (_tmp7_);
		}
	} else {
		GtkSwitch* _tmp28_;
		gboolean _tmp29_;
		_tmp28_ = _data20_->custom_value_switch;
		_tmp29_ = gtk_switch_get_active (_tmp28_);
		if (_tmp29_) {
			Key* _tmp30_;
			KeyEditorChild* _tmp31_;
			gulong _tmp32_;
			KeyEditorChild* _tmp33_;
			Key* _tmp34_;
			GVariant* _tmp35_;
			GVariant* _tmp36_;
			GVariant* _tmp37_;
			const gchar* _tmp38_;
			KeyEditorChild* _tmp44_;
			gulong _tmp45_;
			_tmp30_ = _data19_->key;
			gsettings_key_set_to_default (G_TYPE_CHECK_INSTANCE_CAST (_tmp30_, TYPE_GSETTINGS_KEY, GSettingsKey));
			_tmp31_ = _data19_->key_editor_child;
			_tmp32_ = _data19_->value_has_changed_handler;
			g_signal_handler_block (_tmp31_, _tmp32_);
			_tmp33_ = _data19_->key_editor_child;
			_tmp34_ = _data19_->key;
			_tmp35_ = key_get_value (_tmp34_);
			_tmp36_ = _tmp35_;
			_tmp37_ = _tmp36_;
			key_editor_child_reload (_tmp33_, _tmp37_);
			_g_variant_unref0 (_tmp37_);
			_tmp38_ = _data19_->tmp_string;
			if (g_strcmp0 (_tmp38_, "<flags>") == 0) {
				Key* _tmp39_;
				Key* _tmp40_;
				GVariant* _tmp41_;
				GVariant* _tmp42_;
				GVariant* _tmp43_;
				_tmp39_ = _data19_->key;
				_tmp40_ = _data19_->key;
				_tmp41_ = key_get_value (_tmp40_);
				_tmp42_ = _tmp41_;
				_tmp43_ = _tmp42_;
				key_set_planned_value (_tmp39_, _tmp43_);
				_g_variant_unref0 (_tmp43_);
			}
			_tmp44_ = _data19_->key_editor_child;
			_tmp45_ = _data19_->value_has_changed_handler;
			g_signal_handler_unblock (_tmp44_, _tmp45_);
		} else {
			Key* _tmp46_;
			Key* _tmp47_;
			GVariant* _tmp48_;
			GVariant* _tmp49_;
			GVariant* _tmp50_;
			_tmp46_ = _data19_->key;
			_tmp47_ = _data19_->key;
			_tmp48_ = key_get_value (_tmp47_);
			_tmp49_ = _tmp48_;
			_tmp50_ = _tmp49_;
			key_set_value (_tmp46_, _tmp50_);
			_g_variant_unref0 (_tmp50_);
		}
	}
}


static void ____lambda49__g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self) {
	___lambda49_ (self);
}


static void ___lambda50_ (Block20Data* _data20_) {
	Block19Data* _data19_;
	RegistryInfo* self;
	GtkSwitch* _tmp0_;
	gulong _tmp1_;
	GtkSwitch* _tmp2_;
	GSettingsKey* _tmp3_;
	gboolean _tmp4_;
	gboolean _tmp5_;
	GtkSwitch* _tmp6_;
	gulong _tmp7_;
	_data19_ = _data20_->_data19_;
	self = _data19_->self;
	_tmp0_ = _data20_->custom_value_switch;
	_tmp1_ = _data20_->switch_active_handler;
	g_signal_handler_block (_tmp0_, _tmp1_);
	_tmp2_ = _data20_->custom_value_switch;
	_tmp3_ = _data20_->gkey;
	_tmp4_ = gsettings_key_get_is_default (_tmp3_);
	_tmp5_ = _tmp4_;
	gtk_switch_set_active (_tmp2_, _tmp5_);
	_tmp6_ = _data20_->custom_value_switch;
	_tmp7_ = _data20_->switch_active_handler;
	g_signal_handler_unblock (_tmp6_, _tmp7_);
}


static void ____lambda50__modifications_revealer_reload (ModificationsRevealer* _sender, gpointer self) {
	___lambda50_ (self);
}


static void ___lambda51_ (Block20Data* _data20_) {
	Block19Data* _data19_;
	RegistryInfo* self;
	GtkSwitch* _tmp0_;
	gulong _tmp1_;
	_data19_ = _data20_->_data19_;
	self = _data19_->self;
	_tmp0_ = _data20_->custom_value_switch;
	_tmp1_ = _data20_->switch_active_handler;
	g_signal_handler_disconnect ((GObject*) _tmp0_, _tmp1_);
}


static void ____lambda51__gtk_widget_destroy (GtkWidget* _sender, gpointer self) {
	___lambda51_ (self);
}


static void ___lambda52_ (Block19Data* _data19_) {
	RegistryInfo* self;
	ModificationsRevealer* _tmp0_;
	ModificationsRevealer* _tmp1_;
	Key* _tmp2_;
	self = _data19_->self;
	_tmp0_ = self->priv->_revealer;
	modifications_revealer_enter_delay_mode (_tmp0_);
	_tmp1_ = self->priv->_revealer;
	_tmp2_ = _data19_->key;
	modifications_revealer_add_delayed_setting (_tmp1_, _tmp2_, NULL);
}


static void ____lambda52__gtk_button_clicked (GtkButton* _sender, gpointer self) {
	___lambda52_ (self);
}


static void __lambda53_ (RegistryInfo* self) {
	ModificationsRevealer* _tmp0_;
	_tmp0_ = self->priv->_revealer;
	modifications_revealer_apply_delayed_settings (_tmp0_);
}


static void ___lambda53__key_editor_child_child_activated (KeyEditorChild* _sender, gpointer self) {
	__lambda53_ ((RegistryInfo*) self);
}


static void __lambda54_ (Block19Data* _data19_) {
	RegistryInfo* self;
	gboolean _tmp0_ = FALSE;
	Key* _tmp1_;
	KeyEditorChild* _tmp5_;
	gulong _tmp6_;
	KeyEditorChild* _tmp7_;
	Key* _tmp8_;
	GVariant* _tmp9_;
	GVariant* _tmp10_;
	GVariant* _tmp11_;
	const gchar* _tmp12_;
	KeyEditorChild* _tmp18_;
	gulong _tmp19_;
	self = _data19_->self;
	_tmp1_ = _data19_->key;
	if (G_TYPE_CHECK_INSTANCE_TYPE (_tmp1_, TYPE_DCONF_KEY)) {
		Key* _tmp2_;
		gboolean _tmp3_;
		gboolean _tmp4_;
		_tmp2_ = _data19_->key;
		_tmp3_ = dconf_key_get_is_ghost (G_TYPE_CHECK_INSTANCE_CAST (_tmp2_, TYPE_DCONF_KEY, DConfKey));
		_tmp4_ = _tmp3_;
		_tmp0_ = _tmp4_;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		return;
	}
	_tmp5_ = _data19_->key_editor_child;
	_tmp6_ = _data19_->value_has_changed_handler;
	g_signal_handler_block (_tmp5_, _tmp6_);
	_tmp7_ = _data19_->key_editor_child;
	_tmp8_ = _data19_->key;
	_tmp9_ = key_get_value (_tmp8_);
	_tmp10_ = _tmp9_;
	_tmp11_ = _tmp10_;
	key_editor_child_reload (_tmp7_, _tmp11_);
	_g_variant_unref0 (_tmp11_);
	_tmp12_ = _data19_->tmp_string;
	if (g_strcmp0 (_tmp12_, "<flags>") == 0) {
		Key* _tmp13_;
		Key* _tmp14_;
		GVariant* _tmp15_;
		GVariant* _tmp16_;
		GVariant* _tmp17_;
		_tmp13_ = _data19_->key;
		_tmp14_ = _data19_->key;
		_tmp15_ = key_get_value (_tmp14_);
		_tmp16_ = _tmp15_;
		_tmp17_ = _tmp16_;
		key_set_planned_value (_tmp13_, _tmp17_);
		_g_variant_unref0 (_tmp17_);
	}
	_tmp18_ = _data19_->key_editor_child;
	_tmp19_ = _data19_->value_has_changed_handler;
	g_signal_handler_unblock (_tmp18_, _tmp19_);
}


static void ___lambda54__modifications_revealer_reload (ModificationsRevealer* _sender, gpointer self) {
	__lambda54_ (self);
}


static void __lambda55_ (Block19Data* _data19_) {
	RegistryInfo* self;
	Key* _tmp0_;
	gulong _tmp1_;
	KeyEditorChild* _tmp2_;
	gulong _tmp3_;
	KeyEditorChild* _tmp4_;
	self = _data19_->self;
	_tmp0_ = _data19_->key;
	_tmp1_ = _data19_->key_value_changed_handler;
	g_signal_handler_disconnect ((GObject*) _tmp0_, _tmp1_);
	_tmp2_ = _data19_->key_editor_child;
	_tmp3_ = _data19_->value_has_changed_handler;
	g_signal_handler_disconnect ((GObject*) _tmp2_, _tmp3_);
	_tmp4_ = _data19_->key_editor_child;
	g_signal_handler_disconnect ((GObject*) _tmp4_, _data19_->child_activated_handler);
}


static void ___lambda55__gtk_widget_destroy (GtkWidget* _sender, gpointer self) {
	__lambda55_ (self);
}


void registry_info_populate_properties_list_box (RegistryInfo* self, Key* key) {
	Block19Data* _data19_;
	Key* _tmp0_;
	Key* _tmp1_;
	gboolean _tmp2_ = FALSE;
	Key* _tmp3_;
	GVariant** dict_container = NULL;
	gint dict_container_length1 = 0;
	gint _dict_container_size_ = 0;
	Key* _tmp7_;
	GVariant* _tmp8_;
	GVariant* _tmp9_;
	GVariant* _tmp10_;
	GtkRevealer* _tmp11_;
	GtkListBox* _tmp12_;
	GVariant* dict = NULL;
	GVariant* _tmp13_;
	GVariant* _tmp14_;
	gchar* key_name = NULL;
	gboolean _tmp15_;
	gboolean _tmp16_;
	gboolean _tmp17_;
	gboolean _tmp19_;
	gboolean _tmp21_;
	gboolean _tmp23_;
	gboolean _tmp25_;
	gboolean _tmp27_;
	gboolean _tmp29_;
	gboolean _tmp31_;
	gboolean _tmp32_ = FALSE;
	Key* _tmp36_;
	gchar* _tmp37_;
	gchar* _tmp38_;
	GtkLabel* _tmp39_;
	GtkLabel* _tmp40_;
	Key* _tmp41_;
	gulong _tmp42_;
	GtkLabel* _tmp43_;
	GtkLabel* _tmp44_;
	GtkLabel* _tmp45_;
	GtkLabel* _tmp46_;
	GtkLabel* _tmp47_;
	GtkLabel* _tmp48_;
	GtkLabel* _tmp49_;
	GtkLabel* _tmp50_;
	GtkLabel* _tmp51_;
	GtkLabel* _tmp52_;
	Key* _tmp53_;
	KeyEditorChild* _tmp54_;
	gboolean is_key_editor_child_single = FALSE;
	KeyEditorChild* _tmp55_;
	gboolean _tmp56_;
	GtkRevealer* _tmp62_;
	gboolean _tmp63_;
	KeyEditorChild* _tmp64_;
	gulong _tmp65_;
	KeyEditorChild* _tmp94_;
	gulong _tmp95_;
	ModificationsRevealer* _tmp96_;
	gulong _tmp97_;
	KeyEditorChild* _tmp98_;
	const gchar* _tmp99_;
	KeyEditorChild* _tmp100_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (key != NULL);
	_data19_ = g_slice_new0 (Block19Data);
	_data19_->_ref_count_ = 1;
	_data19_->self = g_object_ref (self);
	_tmp0_ = key;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (_data19_->key);
	_data19_->key = _tmp1_;
	_tmp3_ = _data19_->key;
	if (G_TYPE_CHECK_INSTANCE_TYPE (_tmp3_, TYPE_DCONF_KEY)) {
		Key* _tmp4_;
		gboolean _tmp5_;
		gboolean _tmp6_;
		_tmp4_ = _data19_->key;
		_tmp5_ = dconf_key_get_is_ghost (G_TYPE_CHECK_INSTANCE_CAST (_tmp4_, TYPE_DCONF_KEY, DConfKey));
		_tmp6_ = _tmp5_;
		_tmp2_ = _tmp6_;
	} else {
		_tmp2_ = FALSE;
	}
	if (_tmp2_) {
		g_assert_not_reached ();
	}
	registry_info_clean (self);
	_tmp7_ = _data19_->key;
	_tmp8_ = key_get_properties (_tmp7_);
	_tmp9_ = _tmp8_;
	_tmp10_ = _tmp9_;
	g_variant_get (_tmp10_, "(ba{ss})", &_data19_->has_schema, &dict_container, NULL);
	_g_variant_unref0 (_tmp10_);
	_tmp11_ = self->priv->no_schema_warning;
	gtk_revealer_set_reveal_child (_tmp11_, !_data19_->has_schema);
	_tmp12_ = self->priv->properties_list_box;
	gtk_container_foreach ((GtkContainer*) _tmp12_, ___lambda24__gtk_callback, self);
	_tmp13_ = dict_container[0];
	_tmp14_ = _g_variant_ref0 (_tmp13_);
	dict = _tmp14_;
	_tmp15_ = g_variant_lookup (dict, "key-name", "s", &key_name, NULL);
	if (!_tmp15_) {
		g_assert_not_reached ();
	}
	_tmp16_ = g_variant_lookup (dict, "parent-path", "s", &_data19_->parent_path, NULL);
	if (!_tmp16_) {
		g_assert_not_reached ();
	}
	_tmp17_ = g_variant_lookup (dict, "schema-id", "s", &_data19_->tmp_string, NULL);
	if (_tmp17_) {
		const gchar* _tmp18_;
		_tmp18_ = _data19_->tmp_string;
		registry_info_add_row_from_label (self, _ ("Schema"), _tmp18_);
	}
	_tmp19_ = g_variant_lookup (dict, "summary", "s", &_data19_->tmp_string, NULL);
	if (_tmp19_) {
		const gchar* _tmp20_;
		_tmp20_ = _data19_->tmp_string;
		registry_info_add_row_from_label (self, _ ("Summary"), _tmp20_);
	}
	_tmp21_ = g_variant_lookup (dict, "description", "s", &_data19_->tmp_string, NULL);
	if (_tmp21_) {
		const gchar* _tmp22_;
		_tmp22_ = _data19_->tmp_string;
		registry_info_add_row_from_label (self, _ ("Description"), _tmp22_);
	}
	_tmp23_ = g_variant_lookup (dict, "type-name", "s", &_data19_->tmp_string, NULL);
	if (_tmp23_) {
		const gchar* _tmp24_;
		_tmp24_ = _data19_->tmp_string;
		registry_info_add_row_from_label (self, _ ("Type"), _tmp24_);
	} else {
		g_assert_not_reached ();
	}
	_tmp25_ = g_variant_lookup (dict, "minimum", "s", &_data19_->tmp_string, NULL);
	if (_tmp25_) {
		const gchar* _tmp26_;
		_tmp26_ = _data19_->tmp_string;
		registry_info_add_row_from_label (self, _ ("Minimum"), _tmp26_);
	}
	_tmp27_ = g_variant_lookup (dict, "maximum", "s", &_data19_->tmp_string, NULL);
	if (_tmp27_) {
		const gchar* _tmp28_;
		_tmp28_ = _data19_->tmp_string;
		registry_info_add_row_from_label (self, _ ("Maximum"), _tmp28_);
	}
	_tmp29_ = g_variant_lookup (dict, "default-value", "s", &_data19_->tmp_string, NULL);
	if (_tmp29_) {
		const gchar* _tmp30_;
		_tmp30_ = _data19_->tmp_string;
		registry_info_add_row_from_label (self, _ ("Default"), _tmp30_);
	}
	_tmp31_ = g_variant_lookup (dict, "type-code", "s", &_data19_->tmp_string, NULL);
	if (!_tmp31_) {
		g_assert_not_reached ();
	}
	if (_data19_->has_schema) {
		Key* _tmp33_;
		gboolean _tmp34_;
		gboolean _tmp35_;
		_tmp33_ = _data19_->key;
		_tmp34_ = gsettings_key_get_is_default (G_TYPE_CHECK_INSTANCE_CAST (_tmp33_, TYPE_GSETTINGS_KEY, GSettingsKey));
		_tmp35_ = _tmp34_;
		_tmp32_ = _tmp35_;
	} else {
		_tmp32_ = FALSE;
	}
	_tmp36_ = _data19_->key;
	_tmp37_ = registry_info_get_current_value_text (_tmp32_, _tmp36_);
	_tmp38_ = _tmp37_;
	_tmp39_ = (GtkLabel*) gtk_label_new (_tmp38_);
	g_object_ref_sink (_tmp39_);
	_tmp40_ = _tmp39_;
	_g_free0 (_tmp38_);
	_data19_->label = _tmp40_;
	_tmp41_ = _data19_->key;
	_tmp42_ = g_signal_connect_data (_tmp41_, "value-changed", (GCallback) ___lambda25__key_value_changed, block19_data_ref (_data19_), (GClosureNotify) block19_data_unref, 0);
	_data19_->key_value_changed_handler = _tmp42_;
	_tmp43_ = _data19_->label;
	gtk_widget_set_halign ((GtkWidget*) _tmp43_, GTK_ALIGN_START);
	_tmp44_ = _data19_->label;
	gtk_widget_set_valign ((GtkWidget*) _tmp44_, GTK_ALIGN_START);
	_tmp45_ = _data19_->label;
	gtk_label_set_xalign (_tmp45_, (gfloat) 0);
	_tmp46_ = _data19_->label;
	gtk_label_set_yalign (_tmp46_, (gfloat) 0);
	_tmp47_ = _data19_->label;
	g_object_set (_tmp47_, "wrap", TRUE, NULL);
	_tmp48_ = _data19_->label;
	gtk_label_set_max_width_chars (_tmp48_, 42);
	_tmp49_ = _data19_->label;
	gtk_label_set_width_chars (_tmp49_, 42);
	_tmp50_ = _data19_->label;
	gtk_widget_set_hexpand ((GtkWidget*) _tmp50_, TRUE);
	_tmp51_ = _data19_->label;
	gtk_widget_show ((GtkWidget*) _tmp51_);
	_tmp52_ = _data19_->label;
	registry_info_add_row_from_widget (self, _ ("Current value"), (GtkWidget*) _tmp52_, NULL);
	registry_info_add_separator (self);
	_tmp53_ = _data19_->key;
	_tmp54_ = registry_info_create_child (_tmp53_, _data19_->has_schema);
	_data19_->key_editor_child = _tmp54_;
	_tmp55_ = _data19_->key_editor_child;
	is_key_editor_child_single = G_TYPE_CHECK_INSTANCE_TYPE (_tmp55_, TYPE_KEY_EDITOR_CHILD_SINGLE);
	_tmp56_ = is_key_editor_child_single;
	if (_tmp56_) {
		gboolean is_enum = FALSE;
		const gchar* _tmp57_;
		GtkLabel* _tmp58_;
		gboolean _tmp59_;
		GtkLabel* _tmp60_;
		gboolean _tmp61_;
		_tmp57_ = _data19_->tmp_string;
		is_enum = g_strcmp0 (_tmp57_, "<enum>") == 0;
		_tmp58_ = self->priv->one_choice_integer_warning;
		_tmp59_ = is_enum;
		gtk_widget_set_visible ((GtkWidget*) _tmp58_, !_tmp59_);
		_tmp60_ = self->priv->one_choice_enum_warning;
		_tmp61_ = is_enum;
		gtk_widget_set_visible ((GtkWidget*) _tmp60_, _tmp61_);
	}
	_tmp62_ = self->priv->one_choice_warning_revealer;
	_tmp63_ = is_key_editor_child_single;
	gtk_revealer_set_reveal_child (_tmp62_, _tmp63_);
	_tmp64_ = _data19_->key_editor_child;
	_tmp65_ = g_signal_connect_data (_tmp64_, "value-has-changed", (GCallback) ___lambda46__key_editor_child_value_has_changed, block19_data_ref (_data19_), (GClosureNotify) block19_data_unref, 0);
	_data19_->value_has_changed_handler = _tmp65_;
	if (_data19_->has_schema) {
		Block20Data* _data20_;
		GtkSwitch* _tmp66_;
		GtkSwitch* _tmp67_;
		GtkSwitch* _tmp68_;
		GtkSwitch* _tmp69_;
		GtkSwitch* _tmp70_;
		GtkSwitch* _tmp71_;
		GtkSwitch* _tmp72_;
		KeyEditorChild* _tmp73_;
		Key* _tmp74_;
		GSettingsKey* _tmp75_;
		gboolean _tmp76_ = FALSE;
		Key* _tmp77_;
		gboolean _tmp78_;
		gboolean _tmp79_;
		GtkSwitch* _tmp86_;
		GtkSwitch* _tmp87_;
		gulong _tmp88_;
		ModificationsRevealer* _tmp89_;
		gulong _tmp90_;
		GtkSwitch* _tmp91_;
		_data20_ = g_slice_new0 (Block20Data);
		_data20_->_ref_count_ = 1;
		_data20_->_data19_ = block19_data_ref (_data19_);
		_tmp66_ = (GtkSwitch*) gtk_switch_new ();
		g_object_ref_sink (_tmp66_);
		_data20_->custom_value_switch = _tmp66_;
		_tmp67_ = _data20_->custom_value_switch;
		gtk_widget_set_can_focus ((GtkWidget*) _tmp67_, FALSE);
		_tmp68_ = _data20_->custom_value_switch;
		gtk_widget_set_halign ((GtkWidget*) _tmp68_, GTK_ALIGN_START);
		_tmp69_ = _data20_->custom_value_switch;
		gtk_widget_set_hexpand ((GtkWidget*) _tmp69_, TRUE);
		_tmp70_ = _data20_->custom_value_switch;
		gtk_widget_show ((GtkWidget*) _tmp70_);
		_tmp71_ = _data20_->custom_value_switch;
		registry_info_add_switch_row (self, _ ("Use default value"), _tmp71_);
		_tmp72_ = _data20_->custom_value_switch;
		_tmp73_ = _data19_->key_editor_child;
		g_object_bind_property_with_closures ((GObject*) _tmp72_, "active", (GObject*) _tmp73_, "sensitive", G_BINDING_SYNC_CREATE | G_BINDING_INVERT_BOOLEAN, (GClosure*) ((NULL == NULL) ? NULL : g_cclosure_new ((GCallback) NULL, NULL, (GClosureNotify) NULL)), (GClosure*) ((NULL == NULL) ? NULL : g_cclosure_new ((GCallback) NULL, NULL, (GClosureNotify) NULL)));
		_tmp74_ = _data19_->key;
		_tmp75_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp74_, TYPE_GSETTINGS_KEY, GSettingsKey));
		_data20_->gkey = _tmp75_;
		_tmp77_ = _data19_->key;
		_tmp78_ = key_get_planned_change (_tmp77_);
		_tmp79_ = _tmp78_;
		if (_tmp79_) {
			Key* _tmp80_;
			GVariant* _tmp81_;
			GVariant* _tmp82_;
			_tmp80_ = _data19_->key;
			_tmp81_ = key_get_planned_value (_tmp80_);
			_tmp82_ = _tmp81_;
			_tmp76_ = _tmp82_ == NULL;
		} else {
			GSettingsKey* _tmp83_;
			gboolean _tmp84_;
			gboolean _tmp85_;
			_tmp83_ = _data20_->gkey;
			_tmp84_ = gsettings_key_get_is_default (_tmp83_);
			_tmp85_ = _tmp84_;
			_tmp76_ = _tmp85_;
		}
		_tmp86_ = _data20_->custom_value_switch;
		gtk_switch_set_active (_tmp86_, _tmp76_);
		_tmp87_ = _data20_->custom_value_switch;
		_tmp88_ = g_signal_connect_data ((GObject*) _tmp87_, "notify::active", (GCallback) ____lambda49__g_object_notify, block20_data_ref (_data20_), (GClosureNotify) block20_data_unref, 0);
		_data20_->switch_active_handler = _tmp88_;
		_tmp89_ = self->priv->_revealer;
		_tmp90_ = g_signal_connect_data (_tmp89_, "reload", (GCallback) ____lambda50__modifications_revealer_reload, block20_data_ref (_data20_), (GClosureNotify) block20_data_unref, 0);
		self->priv->revealer_reload_1_handler = _tmp90_;
		_tmp91_ = _data20_->custom_value_switch;
		g_signal_connect_data ((GtkWidget*) _tmp91_, "destroy", (GCallback) ____lambda51__gtk_widget_destroy, block20_data_ref (_data20_), (GClosureNotify) block20_data_unref, 0);
		block20_data_unref (_data20_);
		_data20_ = NULL;
	} else {
		GtkButton* _tmp92_;
		gulong _tmp93_;
		_tmp92_ = self->priv->erase_button;
		_tmp93_ = g_signal_connect_data (_tmp92_, "clicked", (GCallback) ____lambda52__gtk_button_clicked, block19_data_ref (_data19_), (GClosureNotify) block19_data_unref, 0);
		self->priv->erase_button_handler = _tmp93_;
	}
	_tmp94_ = _data19_->key_editor_child;
	_tmp95_ = g_signal_connect_object (_tmp94_, "child-activated", (GCallback) ___lambda53__key_editor_child_child_activated, self, 0);
	_data19_->child_activated_handler = _tmp95_;
	_tmp96_ = self->priv->_revealer;
	_tmp97_ = g_signal_connect_data (_tmp96_, "reload", (GCallback) ___lambda54__modifications_revealer_reload, block19_data_ref (_data19_), (GClosureNotify) block19_data_unref, 0);
	self->priv->revealer_reload_2_handler = _tmp97_;
	_tmp98_ = _data19_->key_editor_child;
	_tmp99_ = _data19_->tmp_string;
	registry_info_add_row_from_widget (self, _ ("Custom value"), (GtkWidget*) _tmp98_, _tmp99_);
	_tmp100_ = _data19_->key_editor_child;
	g_signal_connect_data ((GtkWidget*) _tmp100_, "destroy", (GCallback) ___lambda55__gtk_widget_destroy, block19_data_ref (_data19_), (GClosureNotify) block19_data_unref, 0);
	_g_free0 (key_name);
	_g_variant_unref0 (dict);
	block19_data_unref (_data19_);
	_data19_ = NULL;
}


static KeyEditorChild* registry_info_create_child (Key* key, gboolean has_schema) {
	KeyEditorChild* result = NULL;
	Key* _tmp0_;
	const gchar* _tmp1_;
	const gchar* _tmp2_;
	const gchar* _tmp3_;
	GQuark _tmp5_ = 0U;
	static GQuark _tmp4_label0 = 0;
	static GQuark _tmp4_label1 = 0;
	static GQuark _tmp4_label2 = 0;
	static GQuark _tmp4_label3 = 0;
	static GQuark _tmp4_label4 = 0;
	static GQuark _tmp4_label5 = 0;
	static GQuark _tmp4_label6 = 0;
	static GQuark _tmp4_label7 = 0;
	static GQuark _tmp4_label8 = 0;
	static GQuark _tmp4_label9 = 0;
	static GQuark _tmp4_label10 = 0;
	g_return_val_if_fail (key != NULL, NULL);
	_tmp0_ = key;
	_tmp1_ = key_get_type_string (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = _tmp2_;
	_tmp5_ = (NULL == _tmp3_) ? 0 : g_quark_from_string (_tmp3_);
	if (_tmp5_ == ((0 != _tmp4_label0) ? _tmp4_label0 : (_tmp4_label0 = g_quark_from_static_string ("<enum>")))) {
		switch (0) {
			default:
			{
				Key* _tmp6_;
				GVariant* _tmp7_;
				GVariant* _tmp8_;
				gsize _tmp9_;
				_tmp6_ = key;
				_tmp7_ = gsettings_key_get_range_content (G_TYPE_CHECK_INSTANCE_CAST (_tmp6_, TYPE_GSETTINGS_KEY, GSettingsKey));
				_tmp8_ = _tmp7_;
				_tmp9_ = g_variant_n_children (_tmp8_);
				switch (_tmp9_) {
					case 0:
					{
						g_assert_not_reached ();
					}
					case 1:
					{
						Key* _tmp10_;
						GVariant* _tmp11_;
						GVariant* _tmp12_;
						GVariant* _tmp13_;
						Key* _tmp14_;
						GVariant* _tmp15_;
						GVariant* _tmp16_;
						GVariant* _tmp17_;
						const gchar* _tmp18_;
						KeyEditorChildSingle* _tmp19_;
						KeyEditorChild* _tmp20_;
						_tmp10_ = key;
						_tmp11_ = key_get_value (_tmp10_);
						_tmp12_ = _tmp11_;
						_tmp13_ = _tmp12_;
						_tmp14_ = key;
						_tmp15_ = key_get_value (_tmp14_);
						_tmp16_ = _tmp15_;
						_tmp17_ = _tmp16_;
						_tmp18_ = g_variant_get_string (_tmp17_, NULL);
						_tmp19_ = key_editor_child_single_new (_tmp13_, _tmp18_);
						g_object_ref_sink (_tmp19_);
						_tmp20_ = G_TYPE_CHECK_INSTANCE_CAST (_tmp19_, TYPE_KEY_EDITOR_CHILD, KeyEditorChild);
						_g_variant_unref0 (_tmp17_);
						_g_variant_unref0 (_tmp13_);
						result = _tmp20_;
						return result;
					}
					default:
					{
						Key* _tmp21_;
						KeyEditorChildEnum* _tmp22_;
						_tmp21_ = key;
						_tmp22_ = key_editor_child_enum_new (_tmp21_);
						g_object_ref_sink (_tmp22_);
						result = G_TYPE_CHECK_INSTANCE_CAST (_tmp22_, TYPE_KEY_EDITOR_CHILD, KeyEditorChild);
						return result;
					}
				}
			}
		}
	} else if (_tmp5_ == ((0 != _tmp4_label1) ? _tmp4_label1 : (_tmp4_label1 = g_quark_from_static_string ("<flags>")))) {
		switch (0) {
			default:
			{
				Key* _tmp23_;
				KeyEditorChildFlags* _tmp24_;
				_tmp23_ = key;
				_tmp24_ = key_editor_child_flags_new (G_TYPE_CHECK_INSTANCE_CAST (_tmp23_, TYPE_GSETTINGS_KEY, GSettingsKey));
				g_object_ref_sink (_tmp24_);
				result = G_TYPE_CHECK_INSTANCE_CAST (_tmp24_, TYPE_KEY_EDITOR_CHILD, KeyEditorChild);
				return result;
			}
		}
	} else if (_tmp5_ == ((0 != _tmp4_label2) ? _tmp4_label2 : (_tmp4_label2 = g_quark_from_static_string ("b")))) {
		switch (0) {
			default:
			{
				gboolean _tmp25_ = FALSE;
				gboolean _tmp26_ = FALSE;
				Key* _tmp27_;
				gboolean _tmp28_;
				gboolean _tmp29_;
				KeyEditorChildBool* _tmp42_;
				_tmp27_ = key;
				_tmp28_ = key_get_planned_change (_tmp27_);
				_tmp29_ = _tmp28_;
				if (_tmp29_) {
					Key* _tmp30_;
					GVariant* _tmp31_;
					GVariant* _tmp32_;
					_tmp30_ = key;
					_tmp31_ = key_get_planned_value (_tmp30_);
					_tmp32_ = _tmp31_;
					_tmp26_ = _tmp32_ != NULL;
				} else {
					_tmp26_ = FALSE;
				}
				if (_tmp26_) {
					Key* _tmp33_;
					GVariant* _tmp34_;
					GVariant* _tmp35_;
					gboolean _tmp36_;
					_tmp33_ = key;
					_tmp34_ = key_get_planned_value (_tmp33_);
					_tmp35_ = _tmp34_;
					_tmp36_ = g_variant_get_boolean ((GVariant*) _tmp35_);
					_tmp25_ = _tmp36_;
				} else {
					Key* _tmp37_;
					GVariant* _tmp38_;
					GVariant* _tmp39_;
					GVariant* _tmp40_;
					gboolean _tmp41_;
					_tmp37_ = key;
					_tmp38_ = key_get_value (_tmp37_);
					_tmp39_ = _tmp38_;
					_tmp40_ = _tmp39_;
					_tmp41_ = g_variant_get_boolean (_tmp40_);
					_tmp25_ = _tmp41_;
					_g_variant_unref0 (_tmp40_);
				}
				_tmp42_ = key_editor_child_bool_new (_tmp25_);
				g_object_ref_sink (_tmp42_);
				result = G_TYPE_CHECK_INSTANCE_CAST (_tmp42_, TYPE_KEY_EDITOR_CHILD, KeyEditorChild);
				return result;
			}
		}
	} else if (((_tmp5_ == ((0 != _tmp4_label3) ? _tmp4_label3 : (_tmp4_label3 = g_quark_from_static_string ("n")))) || (_tmp5_ == ((0 != _tmp4_label4) ? _tmp4_label4 : (_tmp4_label4 = g_quark_from_static_string ("i"))))) || (_tmp5_ == ((0 != _tmp4_label5) ? _tmp4_label5 : (_tmp4_label5 = g_quark_from_static_string ("h"))))) {
		switch (0) {
			default:
			{
				GVariant* range = NULL;
				Key* _tmp43_;
				GVariant* _tmp44_;
				GVariant* _tmp45_;
				GVariant* _tmp46_;
				gboolean _tmp47_ = FALSE;
				gboolean _tmp48_ = FALSE;
				gboolean _tmp49_;
				_tmp43_ = key;
				_tmp44_ = gsettings_key_get_range_content (G_TYPE_CHECK_INSTANCE_CAST (_tmp43_, TYPE_GSETTINGS_KEY, GSettingsKey));
				_tmp45_ = _tmp44_;
				_tmp46_ = _g_variant_ref0 (_tmp45_);
				range = _tmp46_;
				_tmp49_ = has_schema;
				if (_tmp49_) {
					Key* _tmp50_;
					const gchar* _tmp51_;
					const gchar* _tmp52_;
					_tmp50_ = key;
					_tmp51_ = gsettings_key_get_range_type (G_TYPE_CHECK_INSTANCE_CAST (_tmp50_, TYPE_GSETTINGS_KEY, GSettingsKey));
					_tmp52_ = _tmp51_;
					_tmp48_ = g_strcmp0 (_tmp52_, "range") == 0;
				} else {
					_tmp48_ = FALSE;
				}
				if (_tmp48_) {
					GVariant* _tmp53_;
					GVariant* _tmp54_;
					GVariant* _tmp55_;
					gint64 _tmp56_;
					GVariant* _tmp57_;
					GVariant* _tmp58_;
					GVariant* _tmp59_;
					gint64 _tmp60_;
					_tmp53_ = range;
					_tmp54_ = g_variant_get_child_value (_tmp53_, (gsize) 0);
					_tmp55_ = _tmp54_;
					_tmp56_ = key_get_variant_as_int64 (_tmp55_);
					_tmp57_ = range;
					_tmp58_ = g_variant_get_child_value (_tmp57_, (gsize) 1);
					_tmp59_ = _tmp58_;
					_tmp60_ = key_get_variant_as_int64 (_tmp59_);
					_tmp47_ = _tmp56_ == _tmp60_;
					_g_variant_unref0 (_tmp59_);
					_g_variant_unref0 (_tmp55_);
				} else {
					_tmp47_ = FALSE;
				}
				if (_tmp47_) {
					Key* _tmp61_;
					GVariant* _tmp62_;
					GVariant* _tmp63_;
					GVariant* _tmp64_;
					Key* _tmp65_;
					GVariant* _tmp66_;
					GVariant* _tmp67_;
					GVariant* _tmp68_;
					gchar* _tmp69_;
					gchar* _tmp70_;
					KeyEditorChildSingle* _tmp71_;
					KeyEditorChild* _tmp72_;
					_tmp61_ = key;
					_tmp62_ = key_get_value (_tmp61_);
					_tmp63_ = _tmp62_;
					_tmp64_ = _tmp63_;
					_tmp65_ = key;
					_tmp66_ = key_get_value (_tmp65_);
					_tmp67_ = _tmp66_;
					_tmp68_ = _tmp67_;
					_tmp69_ = g_variant_print (_tmp68_, FALSE);
					_tmp70_ = _tmp69_;
					_tmp71_ = key_editor_child_single_new (_tmp64_, _tmp70_);
					g_object_ref_sink (_tmp71_);
					_tmp72_ = G_TYPE_CHECK_INSTANCE_CAST (_tmp71_, TYPE_KEY_EDITOR_CHILD, KeyEditorChild);
					_g_free0 (_tmp70_);
					_g_variant_unref0 (_tmp68_);
					_g_variant_unref0 (_tmp64_);
					result = _tmp72_;
					_g_variant_unref0 (range);
					return result;
				} else {
					Key* _tmp73_;
					KeyEditorChildNumberInt* _tmp74_;
					_tmp73_ = key;
					_tmp74_ = key_editor_child_number_int_new (_tmp73_);
					g_object_ref_sink (_tmp74_);
					result = G_TYPE_CHECK_INSTANCE_CAST (_tmp74_, TYPE_KEY_EDITOR_CHILD, KeyEditorChild);
					_g_variant_unref0 (range);
					return result;
				}
				_g_variant_unref0 (range);
			}
		}
	} else if (((_tmp5_ == ((0 != _tmp4_label6) ? _tmp4_label6 : (_tmp4_label6 = g_quark_from_static_string ("y")))) || (_tmp5_ == ((0 != _tmp4_label7) ? _tmp4_label7 : (_tmp4_label7 = g_quark_from_static_string ("q"))))) || (_tmp5_ == ((0 != _tmp4_label8) ? _tmp4_label8 : (_tmp4_label8 = g_quark_from_static_string ("u"))))) {
		switch (0) {
			default:
			{
				GVariant* range = NULL;
				Key* _tmp75_;
				GVariant* _tmp76_;
				GVariant* _tmp77_;
				GVariant* _tmp78_;
				gboolean _tmp79_ = FALSE;
				gboolean _tmp80_ = FALSE;
				gboolean _tmp81_;
				_tmp75_ = key;
				_tmp76_ = gsettings_key_get_range_content (G_TYPE_CHECK_INSTANCE_CAST (_tmp75_, TYPE_GSETTINGS_KEY, GSettingsKey));
				_tmp77_ = _tmp76_;
				_tmp78_ = _g_variant_ref0 (_tmp77_);
				range = _tmp78_;
				_tmp81_ = has_schema;
				if (_tmp81_) {
					Key* _tmp82_;
					const gchar* _tmp83_;
					const gchar* _tmp84_;
					_tmp82_ = key;
					_tmp83_ = gsettings_key_get_range_type (G_TYPE_CHECK_INSTANCE_CAST (_tmp82_, TYPE_GSETTINGS_KEY, GSettingsKey));
					_tmp84_ = _tmp83_;
					_tmp80_ = g_strcmp0 (_tmp84_, "range") == 0;
				} else {
					_tmp80_ = FALSE;
				}
				if (_tmp80_) {
					GVariant* _tmp85_;
					GVariant* _tmp86_;
					GVariant* _tmp87_;
					guint64 _tmp88_;
					GVariant* _tmp89_;
					GVariant* _tmp90_;
					GVariant* _tmp91_;
					guint64 _tmp92_;
					_tmp85_ = range;
					_tmp86_ = g_variant_get_child_value (_tmp85_, (gsize) 0);
					_tmp87_ = _tmp86_;
					_tmp88_ = key_get_variant_as_uint64 (_tmp87_);
					_tmp89_ = range;
					_tmp90_ = g_variant_get_child_value (_tmp89_, (gsize) 1);
					_tmp91_ = _tmp90_;
					_tmp92_ = key_get_variant_as_uint64 (_tmp91_);
					_tmp79_ = _tmp88_ == _tmp92_;
					_g_variant_unref0 (_tmp91_);
					_g_variant_unref0 (_tmp87_);
				} else {
					_tmp79_ = FALSE;
				}
				if (_tmp79_) {
					Key* _tmp93_;
					GVariant* _tmp94_;
					GVariant* _tmp95_;
					GVariant* _tmp96_;
					Key* _tmp97_;
					GVariant* _tmp98_;
					GVariant* _tmp99_;
					GVariant* _tmp100_;
					gchar* _tmp101_;
					gchar* _tmp102_;
					KeyEditorChildSingle* _tmp103_;
					KeyEditorChild* _tmp104_;
					_tmp93_ = key;
					_tmp94_ = key_get_value (_tmp93_);
					_tmp95_ = _tmp94_;
					_tmp96_ = _tmp95_;
					_tmp97_ = key;
					_tmp98_ = key_get_value (_tmp97_);
					_tmp99_ = _tmp98_;
					_tmp100_ = _tmp99_;
					_tmp101_ = g_variant_print (_tmp100_, FALSE);
					_tmp102_ = _tmp101_;
					_tmp103_ = key_editor_child_single_new (_tmp96_, _tmp102_);
					g_object_ref_sink (_tmp103_);
					_tmp104_ = G_TYPE_CHECK_INSTANCE_CAST (_tmp103_, TYPE_KEY_EDITOR_CHILD, KeyEditorChild);
					_g_free0 (_tmp102_);
					_g_variant_unref0 (_tmp100_);
					_g_variant_unref0 (_tmp96_);
					result = _tmp104_;
					_g_variant_unref0 (range);
					return result;
				} else {
					Key* _tmp105_;
					KeyEditorChildNumberInt* _tmp106_;
					_tmp105_ = key;
					_tmp106_ = key_editor_child_number_int_new (_tmp105_);
					g_object_ref_sink (_tmp106_);
					result = G_TYPE_CHECK_INSTANCE_CAST (_tmp106_, TYPE_KEY_EDITOR_CHILD, KeyEditorChild);
					_g_variant_unref0 (range);
					return result;
				}
				_g_variant_unref0 (range);
			}
		}
	} else if (_tmp5_ == ((0 != _tmp4_label9) ? _tmp4_label9 : (_tmp4_label9 = g_quark_from_static_string ("d")))) {
		switch (0) {
			default:
			{
				Key* _tmp107_;
				KeyEditorChildNumberDouble* _tmp108_;
				_tmp107_ = key;
				_tmp108_ = key_editor_child_number_double_new (_tmp107_);
				g_object_ref_sink (_tmp108_);
				result = G_TYPE_CHECK_INSTANCE_CAST (_tmp108_, TYPE_KEY_EDITOR_CHILD, KeyEditorChild);
				return result;
			}
		}
	} else if (_tmp5_ == ((0 != _tmp4_label10) ? _tmp4_label10 : (_tmp4_label10 = g_quark_from_static_string ("mb")))) {
		switch (0) {
			default:
			{
				Key* _tmp109_;
				KeyEditorChildNullableBool* _tmp110_;
				_tmp109_ = key;
				_tmp110_ = key_editor_child_nullable_bool_new (_tmp109_);
				g_object_ref_sink (_tmp110_);
				result = G_TYPE_CHECK_INSTANCE_CAST (_tmp110_, TYPE_KEY_EDITOR_CHILD, KeyEditorChild);
				return result;
			}
		}
	} else {
		switch (0) {
			default:
			{
				GVariant* _tmp111_ = NULL;
				gboolean _tmp112_ = FALSE;
				Key* _tmp113_;
				gboolean _tmp114_;
				gboolean _tmp115_;
				Key* _tmp126_;
				const gchar* _tmp127_;
				const gchar* _tmp128_;
				KeyEditorChildDefault* _tmp129_;
				_tmp113_ = key;
				_tmp114_ = key_get_planned_change (_tmp113_);
				_tmp115_ = _tmp114_;
				if (_tmp115_) {
					Key* _tmp116_;
					GVariant* _tmp117_;
					GVariant* _tmp118_;
					_tmp116_ = key;
					_tmp117_ = key_get_planned_value (_tmp116_);
					_tmp118_ = _tmp117_;
					_tmp112_ = _tmp118_ != NULL;
				} else {
					_tmp112_ = FALSE;
				}
				if (_tmp112_) {
					Key* _tmp119_;
					GVariant* _tmp120_;
					GVariant* _tmp121_;
					GVariant* _tmp122_;
					_tmp119_ = key;
					_tmp120_ = key_get_planned_value (_tmp119_);
					_tmp121_ = _tmp120_;
					_tmp122_ = _g_variant_ref0 ((GVariant*) _tmp121_);
					_g_variant_unref0 (_tmp111_);
					_tmp111_ = _tmp122_;
				} else {
					Key* _tmp123_;
					GVariant* _tmp124_;
					GVariant* _tmp125_;
					_tmp123_ = key;
					_tmp124_ = key_get_value (_tmp123_);
					_tmp125_ = _tmp124_;
					_g_variant_unref0 (_tmp111_);
					_tmp111_ = _tmp125_;
				}
				_tmp126_ = key;
				_tmp127_ = key_get_type_string (_tmp126_);
				_tmp128_ = _tmp127_;
				_tmp129_ = key_editor_child_default_new (_tmp128_, _tmp111_);
				g_object_ref_sink (_tmp129_);
				result = G_TYPE_CHECK_INSTANCE_CAST (_tmp129_, TYPE_KEY_EDITOR_CHILD, KeyEditorChild);
				_g_variant_unref0 (_tmp111_);
				return result;
			}
		}
	}
}


static gchar* registry_info_get_current_value_text (gboolean is_default, Key* key) {
	gchar* result = NULL;
	gboolean _tmp0_;
	g_return_val_if_fail (key != NULL, NULL);
	_tmp0_ = is_default;
	if (_tmp0_) {
		gchar* _tmp1_;
		_tmp1_ = g_strdup (_ ("Default value"));
		result = _tmp1_;
		return result;
	} else {
		Key* _tmp2_;
		GVariant* _tmp3_;
		GVariant* _tmp4_;
		GVariant* _tmp5_;
		Key* _tmp6_;
		const gchar* _tmp7_;
		const gchar* _tmp8_;
		gchar* _tmp9_;
		gchar* _tmp10_;
		_tmp2_ = key;
		_tmp3_ = key_get_value (_tmp2_);
		_tmp4_ = _tmp3_;
		_tmp5_ = _tmp4_;
		_tmp6_ = key;
		_tmp7_ = key_get_type_string (_tmp6_);
		_tmp8_ = _tmp7_;
		_tmp9_ = key_cool_text_value_from_variant (_tmp5_, _tmp8_);
		_tmp10_ = _tmp9_;
		_g_variant_unref0 (_tmp5_);
		result = _tmp10_;
		return result;
	}
}


gchar* registry_info_get_copy_text (RegistryInfo* self) {
	gchar* result = NULL;
	GtkWidget* focused_row = NULL;
	GtkListBox* _tmp0_;
	GtkWidget* _tmp1_;
	GtkWidget* _tmp2_;
	GtkWidget* _tmp3_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->properties_list_box;
	_tmp1_ = gtk_container_get_focus_child ((GtkContainer*) _tmp0_);
	_tmp2_ = _g_object_ref0 (_tmp1_);
	focused_row = _tmp2_;
	_tmp3_ = focused_row;
	if (_tmp3_ == NULL) {
		result = NULL;
		_g_object_unref0 (focused_row);
		return result;
	} else {
		GtkWidget* _tmp4_;
		_tmp4_ = focused_row;
		if (G_TYPE_CHECK_INSTANCE_TYPE (G_TYPE_CHECK_INSTANCE_CAST (_tmp4_, gtk_widget_get_type (), GtkWidget), TYPE_PROPERTY_ROW)) {
			GtkWidget* _tmp5_;
			gchar* _tmp6_;
			_tmp5_ = focused_row;
			_tmp6_ = property_row_get_copy_text (G_TYPE_CHECK_INSTANCE_CAST (G_TYPE_CHECK_INSTANCE_CAST (_tmp5_, gtk_widget_get_type (), GtkWidget), TYPE_PROPERTY_ROW, PropertyRow));
			result = _tmp6_;
			_g_object_unref0 (focused_row);
			return result;
		} else {
			result = NULL;
			_g_object_unref0 (focused_row);
			return result;
		}
	}
	_g_object_unref0 (focused_row);
}


static void registry_info_add_row_from_label (RegistryInfo* self, const gchar* property_name, const gchar* property_value) {
	GtkListBox* _tmp0_;
	const gchar* _tmp1_;
	const gchar* _tmp2_;
	PropertyRow* _tmp3_;
	PropertyRow* _tmp4_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (property_name != NULL);
	g_return_if_fail (property_value != NULL);
	_tmp0_ = self->priv->properties_list_box;
	_tmp1_ = property_name;
	_tmp2_ = property_value;
	_tmp3_ = property_row_new_from_label (_tmp1_, _tmp2_);
	g_object_ref_sink (_tmp3_);
	_tmp4_ = _tmp3_;
	gtk_container_add ((GtkContainer*) _tmp0_, (GtkWidget*) _tmp4_);
	_g_object_unref0 (_tmp4_);
}


static Block21Data* block21_data_ref (Block21Data* _data21_) {
	g_atomic_int_inc (&_data21_->_ref_count_);
	return _data21_;
}


static void block21_data_unref (void * _userdata_) {
	Block21Data* _data21_;
	_data21_ = (Block21Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data21_->_ref_count_)) {
		RegistryInfo* self;
		self = _data21_->self;
		_g_object_unref0 (_data21_->row);
		_g_object_unref0 (_data21_->custom_value_switch);
		_g_object_unref0 (self);
		g_slice_free (Block21Data, _data21_);
	}
}


static void __lambda47_ (Block21Data* _data21_) {
	RegistryInfo* self;
	GtkSwitch* _tmp0_;
	GtkSwitch* _tmp1_;
	gboolean _tmp2_;
	self = _data21_->self;
	_tmp0_ = _data21_->custom_value_switch;
	_tmp1_ = _data21_->custom_value_switch;
	_tmp2_ = gtk_switch_get_active (_tmp1_);
	gtk_switch_set_active (_tmp0_, !_tmp2_);
}


static void ___lambda47__gtk_list_box_row_activate (GtkListBoxRow* _sender, gpointer self) {
	__lambda47_ (self);
}


static void __lambda48_ (Block21Data* _data21_) {
	RegistryInfo* self;
	self = _data21_->self;
	g_signal_handler_disconnect ((GObject*) _data21_->row, _data21_->default_value_row_activate_handler);
}


static void ___lambda48__gtk_widget_destroy (GtkWidget* _sender, gpointer self) {
	__lambda48_ (self);
}


static void registry_info_add_switch_row (RegistryInfo* self, const gchar* property_name, GtkSwitch* custom_value_switch) {
	Block21Data* _data21_;
	GtkSwitch* _tmp0_;
	GtkSwitch* _tmp1_;
	const gchar* _tmp2_;
	GtkSwitch* _tmp3_;
	PropertyRow* _tmp4_;
	gulong _tmp5_;
	GtkListBox* _tmp6_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (property_name != NULL);
	g_return_if_fail (custom_value_switch != NULL);
	_data21_ = g_slice_new0 (Block21Data);
	_data21_->_ref_count_ = 1;
	_data21_->self = g_object_ref (self);
	_tmp0_ = custom_value_switch;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (_data21_->custom_value_switch);
	_data21_->custom_value_switch = _tmp1_;
	_tmp2_ = property_name;
	_tmp3_ = _data21_->custom_value_switch;
	_tmp4_ = property_row_new_from_widgets (_tmp2_, (GtkWidget*) _tmp3_, NULL);
	g_object_ref_sink (_tmp4_);
	_data21_->row = _tmp4_;
	_tmp5_ = g_signal_connect_data ((GtkListBoxRow*) _data21_->row, "activate", (GCallback) ___lambda47__gtk_list_box_row_activate, block21_data_ref (_data21_), (GClosureNotify) block21_data_unref, 0);
	_data21_->default_value_row_activate_handler = _tmp5_;
	g_signal_connect_data ((GtkWidget*) _data21_->row, "destroy", (GCallback) ___lambda48__gtk_widget_destroy, block21_data_ref (_data21_), (GClosureNotify) block21_data_unref, 0);
	_tmp6_ = self->priv->properties_list_box;
	gtk_container_add ((GtkContainer*) _tmp6_, (GtkWidget*) _data21_->row);
	block21_data_unref (_data21_);
	_data21_ = NULL;
}


static void registry_info_add_row_from_widget (RegistryInfo* self, const gchar* property_name, GtkWidget* widget, const gchar* type) {
	GtkWidget* _tmp0_ = NULL;
	const gchar* _tmp1_;
	PropertyRow* row = NULL;
	const gchar* _tmp4_;
	GtkWidget* _tmp5_;
	PropertyRow* _tmp6_;
	GtkWidget* _tmp7_;
	GtkListBox* _tmp8_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (property_name != NULL);
	g_return_if_fail (widget != NULL);
	_tmp1_ = type;
	if (_tmp1_ != NULL) {
		const gchar* _tmp2_;
		GtkWidget* _tmp3_;
		_tmp2_ = type;
		_tmp3_ = registry_info_add_warning ((const gchar*) _tmp2_);
		_g_object_unref0 (_tmp0_);
		_tmp0_ = _tmp3_;
	} else {
		_g_object_unref0 (_tmp0_);
		_tmp0_ = NULL;
	}
	_tmp4_ = property_name;
	_tmp5_ = widget;
	_tmp6_ = property_row_new_from_widgets (_tmp4_, _tmp5_, _tmp0_);
	g_object_ref_sink (_tmp6_);
	row = _tmp6_;
	_tmp7_ = widget;
	g_object_bind_property_with_closures ((GObject*) _tmp7_, "sensitive", (GObject*) row, "sensitive", G_BINDING_SYNC_CREATE, (GClosure*) ((NULL == NULL) ? NULL : g_cclosure_new ((GCallback) NULL, NULL, (GClosureNotify) NULL)), (GClosure*) ((NULL == NULL) ? NULL : g_cclosure_new ((GCallback) NULL, NULL, (GClosureNotify) NULL)));
	_tmp8_ = self->priv->properties_list_box;
	gtk_container_add ((GtkContainer*) _tmp8_, (GtkWidget*) row);
	_g_object_unref0 (row);
	_g_object_unref0 (_tmp0_);
}


static void registry_info_add_separator (RegistryInfo* self) {
	GtkSeparator* separator = NULL;
	GtkSeparator* _tmp0_;
	GtkListBoxRow* row = NULL;
	GtkListBoxRow* _tmp1_;
	GtkListBox* _tmp2_;
	g_return_if_fail (self != NULL);
	_tmp0_ = (GtkSeparator*) gtk_separator_new (GTK_ORIENTATION_HORIZONTAL);
	g_object_ref_sink (_tmp0_);
	separator = _tmp0_;
	gtk_widget_set_halign ((GtkWidget*) separator, GTK_ALIGN_CENTER);
	g_object_set ((GtkWidget*) separator, "width-request", 620, NULL);
	gtk_widget_set_margin_bottom ((GtkWidget*) separator, 5);
	gtk_widget_set_margin_top ((GtkWidget*) separator, 5);
	gtk_widget_show ((GtkWidget*) separator);
	_tmp1_ = (GtkListBoxRow*) gtk_list_box_row_new ();
	g_object_ref_sink (_tmp1_);
	row = _tmp1_;
	gtk_container_add ((GtkContainer*) row, (GtkWidget*) separator);
	gtk_widget_set_sensitive ((GtkWidget*) row, FALSE);
	gtk_widget_show ((GtkWidget*) row);
	_tmp2_ = self->priv->properties_list_box;
	gtk_container_add ((GtkContainer*) _tmp2_, (GtkWidget*) row);
	_g_object_unref0 (row);
	_g_object_unref0 (separator);
}


static gboolean string_contains (const gchar* self, const gchar* needle) {
	gboolean result = FALSE;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (needle != NULL, FALSE);
	_tmp0_ = needle;
	_tmp1_ = strstr ((gchar*) self, (gchar*) _tmp0_);
	result = _tmp1_ != NULL;
	return result;
}


static GtkWidget* registry_info_add_warning (const gchar* type) {
	GtkWidget* result = NULL;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	const gchar* _tmp2_;
	g_return_val_if_fail (type != NULL, NULL);
	_tmp2_ = type;
	if (g_strcmp0 (_tmp2_, "<flags>") != 0) {
		gboolean _tmp3_ = FALSE;
		gboolean _tmp4_ = FALSE;
		const gchar* _tmp5_;
		_tmp5_ = type;
		if (g_strcmp0 (_tmp5_, "s") != 0) {
			const gchar* _tmp6_;
			gboolean _tmp7_;
			_tmp6_ = type;
			_tmp7_ = string_contains (_tmp6_, "s");
			_tmp4_ = _tmp7_;
		} else {
			_tmp4_ = FALSE;
		}
		if (_tmp4_) {
			_tmp3_ = TRUE;
		} else {
			gboolean _tmp8_ = FALSE;
			const gchar* _tmp9_;
			_tmp9_ = type;
			if (g_strcmp0 (_tmp9_, "g") != 0) {
				const gchar* _tmp10_;
				gboolean _tmp11_;
				_tmp10_ = type;
				_tmp11_ = string_contains (_tmp10_, "g");
				_tmp8_ = _tmp11_;
			} else {
				_tmp8_ = FALSE;
			}
			_tmp3_ = _tmp8_;
		}
		_tmp1_ = _tmp3_;
	} else {
		_tmp1_ = FALSE;
	}
	if (_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		gboolean _tmp12_ = FALSE;
		const gchar* _tmp13_;
		_tmp13_ = type;
		if (g_strcmp0 (_tmp13_, "o") != 0) {
			const gchar* _tmp14_;
			gboolean _tmp15_;
			_tmp14_ = type;
			_tmp15_ = string_contains (_tmp14_, "o");
			_tmp12_ = _tmp15_;
		} else {
			_tmp12_ = FALSE;
		}
		_tmp0_ = _tmp12_;
	}
	if (_tmp0_) {
		const gchar* _tmp16_;
		gboolean _tmp17_;
		_tmp16_ = type;
		_tmp17_ = string_contains (_tmp16_, "m");
		if (_tmp17_) {
			GtkWidget* _tmp18_;
			_tmp18_ = registry_info_warning_label (_ ("Use the keyword “nothing” to set a maybe type (beginning with “m”) to " \
"its empty value. Strings, signatures and object paths should be surrou" \
"nded by quotation marks."));
			result = _tmp18_;
			return result;
		} else {
			GtkWidget* _tmp19_;
			_tmp19_ = registry_info_warning_label (_ ("Strings, signatures and object paths should be surrounded by quotation" \
" marks."));
			result = _tmp19_;
			return result;
		}
	} else {
		gboolean _tmp20_ = FALSE;
		gboolean _tmp21_ = FALSE;
		gboolean _tmp22_ = FALSE;
		const gchar* _tmp23_;
		_tmp23_ = type;
		if (g_strcmp0 (_tmp23_, "m") != 0) {
			const gchar* _tmp24_;
			_tmp24_ = type;
			_tmp22_ = g_strcmp0 (_tmp24_, "mb") != 0;
		} else {
			_tmp22_ = FALSE;
		}
		if (_tmp22_) {
			const gchar* _tmp25_;
			_tmp25_ = type;
			_tmp21_ = g_strcmp0 (_tmp25_, "<enum>") != 0;
		} else {
			_tmp21_ = FALSE;
		}
		if (_tmp21_) {
			const gchar* _tmp26_;
			gboolean _tmp27_;
			_tmp26_ = type;
			_tmp27_ = string_contains (_tmp26_, "m");
			_tmp20_ = _tmp27_;
		} else {
			_tmp20_ = FALSE;
		}
		if (_tmp20_) {
			GtkWidget* _tmp28_;
			_tmp28_ = registry_info_warning_label (_ ("Use the keyword “nothing” to set a maybe type (beginning with “m”) to " \
"its empty value."));
			result = _tmp28_;
			return result;
		}
	}
	result = NULL;
	return result;
}


static GtkWidget* registry_info_warning_label (const gchar* text) {
	GtkWidget* result = NULL;
	GtkLabel* label = NULL;
	const gchar* _tmp0_;
	GtkLabel* _tmp1_;
	GtkStyleContext* context = NULL;
	GtkStyleContext* _tmp2_;
	GtkStyleContext* _tmp3_;
	GtkWidget* _tmp4_;
	g_return_val_if_fail (text != NULL, NULL);
	_tmp0_ = text;
	_tmp1_ = (GtkLabel*) gtk_label_new (_tmp0_);
	g_object_ref_sink (_tmp1_);
	label = _tmp1_;
	gtk_label_set_max_width_chars (label, 59);
	g_object_set (label, "wrap", TRUE, NULL);
	_tmp2_ = gtk_widget_get_style_context ((GtkWidget*) label);
	_tmp3_ = _g_object_ref0 (_tmp2_);
	context = _tmp3_;
	gtk_style_context_add_class (context, "italic-label");
	gtk_style_context_add_class (context, "greyed-label");
	_tmp4_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (label, gtk_widget_get_type (), GtkWidget));
	result = _tmp4_;
	_g_object_unref0 (context);
	_g_object_unref0 (label);
	return result;
}


RegistryInfo* registry_info_construct (GType object_type) {
	RegistryInfo * self = NULL;
	self = (RegistryInfo*) g_object_new (object_type, NULL);
	return self;
}


RegistryInfo* registry_info_new (void) {
	return registry_info_construct (TYPE_REGISTRY_INFO);
}


ModificationsRevealer* registry_info_get_revealer (RegistryInfo* self) {
	ModificationsRevealer* result;
	ModificationsRevealer* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_revealer;
	result = _tmp0_;
	return result;
}


void registry_info_set_revealer (RegistryInfo* self, ModificationsRevealer* value) {
	g_return_if_fail (self != NULL);
	if (registry_info_get_revealer (self) != value) {
		ModificationsRevealer* _tmp0_;
		ModificationsRevealer* _tmp1_;
		_tmp0_ = value;
		_tmp1_ = _g_object_ref0 (_tmp0_);
		_g_object_unref0 (self->priv->_revealer);
		self->priv->_revealer = _tmp1_;
		g_object_notify_by_pspec ((GObject *) self, registry_info_properties[REGISTRY_INFO_REVEALER_PROPERTY]);
	}
}


static void registry_info_class_init (RegistryInfoClass * klass) {
	gint RegistryInfo_private_offset;
	registry_info_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (RegistryInfoPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_registry_info_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_registry_info_set_property;
	G_OBJECT_CLASS (klass)->finalize = registry_info_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), REGISTRY_INFO_REVEALER_PROPERTY, registry_info_properties[REGISTRY_INFO_REVEALER_PROPERTY] = g_param_spec_object ("revealer", "revealer", "revealer", TYPE_MODIFICATIONS_REVEALER, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	RegistryInfo_private_offset = g_type_class_get_instance_private_offset (klass);
	gtk_widget_class_set_template_from_resource (GTK_WIDGET_CLASS (klass), "/ca/desrt/dconf-editor/ui/registry-info.ui");
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "no_schema_warning", FALSE, RegistryInfo_private_offset + G_STRUCT_OFFSET (RegistryInfoPrivate, no_schema_warning));
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "one_choice_warning_revealer", FALSE, RegistryInfo_private_offset + G_STRUCT_OFFSET (RegistryInfoPrivate, one_choice_warning_revealer));
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "one_choice_enum_warning", FALSE, RegistryInfo_private_offset + G_STRUCT_OFFSET (RegistryInfoPrivate, one_choice_enum_warning));
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "one_choice_integer_warning", FALSE, RegistryInfo_private_offset + G_STRUCT_OFFSET (RegistryInfoPrivate, one_choice_integer_warning));
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "properties_list_box", FALSE, RegistryInfo_private_offset + G_STRUCT_OFFSET (RegistryInfoPrivate, properties_list_box));
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "erase_button", FALSE, RegistryInfo_private_offset + G_STRUCT_OFFSET (RegistryInfoPrivate, erase_button));
}


static void registry_info_instance_init (RegistryInfo * self) {
	self->priv = REGISTRY_INFO_GET_PRIVATE (self);
	self->priv->erase_button_handler = (gulong) 0;
	self->priv->revealer_reload_1_handler = (gulong) 0;
	self->priv->revealer_reload_2_handler = (gulong) 0;
	gtk_widget_init_template (GTK_WIDGET (self));
}


static void registry_info_finalize (GObject * obj) {
	RegistryInfo * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_REGISTRY_INFO, RegistryInfo);
	_g_object_unref0 (self->priv->no_schema_warning);
	_g_object_unref0 (self->priv->one_choice_warning_revealer);
	_g_object_unref0 (self->priv->one_choice_enum_warning);
	_g_object_unref0 (self->priv->one_choice_integer_warning);
	_g_object_unref0 (self->priv->properties_list_box);
	_g_object_unref0 (self->priv->erase_button);
	_g_object_unref0 (self->priv->_revealer);
	G_OBJECT_CLASS (registry_info_parent_class)->finalize (obj);
}


GType registry_info_get_type (void) {
	static volatile gsize registry_info_type_id__volatile = 0;
	if (g_once_init_enter (&registry_info_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (RegistryInfoClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) registry_info_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RegistryInfo), 0, (GInstanceInitFunc) registry_info_instance_init, NULL };
		GType registry_info_type_id;
		registry_info_type_id = g_type_register_static (gtk_grid_get_type (), "RegistryInfo", &g_define_type_info, 0);
		g_once_init_leave (&registry_info_type_id__volatile, registry_info_type_id);
	}
	return registry_info_type_id__volatile;
}


static void _vala_registry_info_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	RegistryInfo * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_REGISTRY_INFO, RegistryInfo);
	switch (property_id) {
		case REGISTRY_INFO_REVEALER_PROPERTY:
		g_value_set_object (value, registry_info_get_revealer (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_registry_info_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	RegistryInfo * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_REGISTRY_INFO, RegistryInfo);
	switch (property_id) {
		case REGISTRY_INFO_REVEALER_PROPERTY:
		registry_info_set_revealer (self, g_value_get_object (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


PropertyRow* property_row_construct_from_label (GType object_type, const gchar* property_name, const gchar* property_value) {
	PropertyRow * self = NULL;
	GtkLabel* _tmp0_;
	const gchar* _tmp1_;
	GtkLabel* value_label = NULL;
	const gchar* _tmp2_;
	GtkLabel* _tmp3_;
	GtkWidget* _tmp4_;
	GtkGrid* _tmp5_;
	g_return_val_if_fail (property_name != NULL, NULL);
	g_return_val_if_fail (property_value != NULL, NULL);
	self = (PropertyRow*) g_object_new (object_type, NULL);
	_tmp0_ = self->priv->name_label;
	_tmp1_ = property_name;
	gtk_label_set_text (_tmp0_, _tmp1_);
	_tmp2_ = property_value;
	_tmp3_ = (GtkLabel*) gtk_label_new (_tmp2_);
	g_object_ref_sink (_tmp3_);
	value_label = _tmp3_;
	_tmp4_ = _g_object_ref0 ((GtkWidget*) value_label);
	_g_object_unref0 (self->priv->value_widget);
	self->priv->value_widget = _tmp4_;
	gtk_widget_set_valign ((GtkWidget*) value_label, GTK_ALIGN_START);
	gtk_label_set_xalign (value_label, (gfloat) 0);
	gtk_label_set_yalign (value_label, (gfloat) 0);
	g_object_set (value_label, "wrap", TRUE, NULL);
	gtk_label_set_max_width_chars (value_label, 42);
	gtk_label_set_width_chars (value_label, 42);
	gtk_widget_show ((GtkWidget*) value_label);
	_tmp5_ = self->priv->grid;
	gtk_grid_attach (_tmp5_, (GtkWidget*) value_label, 1, 0, 1, 1);
	_g_object_unref0 (value_label);
	return self;
}


PropertyRow* property_row_new_from_label (const gchar* property_name, const gchar* property_value) {
	return property_row_construct_from_label (TYPE_PROPERTY_ROW, property_name, property_value);
}


PropertyRow* property_row_construct_from_widgets (GType object_type, const gchar* property_name, GtkWidget* widget, GtkWidget* warning) {
	PropertyRow * self = NULL;
	GtkLabel* _tmp0_;
	const gchar* _tmp1_;
	GtkWidget* _tmp2_;
	GtkGrid* _tmp5_;
	GtkWidget* _tmp6_;
	GtkWidget* _tmp7_;
	GtkWidget* _tmp8_;
	g_return_val_if_fail (property_name != NULL, NULL);
	g_return_val_if_fail (widget != NULL, NULL);
	self = (PropertyRow*) g_object_new (object_type, NULL);
	_tmp0_ = self->priv->name_label;
	_tmp1_ = property_name;
	gtk_label_set_text (_tmp0_, _tmp1_);
	_tmp2_ = widget;
	if (G_TYPE_CHECK_INSTANCE_TYPE (_tmp2_, gtk_label_get_type ())) {
		GtkWidget* _tmp3_;
		GtkWidget* _tmp4_;
		_tmp3_ = widget;
		_tmp4_ = _g_object_ref0 (_tmp3_);
		_g_object_unref0 (self->priv->value_widget);
		self->priv->value_widget = _tmp4_;
	}
	_tmp5_ = self->priv->grid;
	_tmp6_ = widget;
	gtk_grid_attach (_tmp5_, _tmp6_, 1, 0, 1, 1);
	_tmp7_ = widget;
	gtk_widget_set_valign (_tmp7_, GTK_ALIGN_CENTER);
	_tmp8_ = warning;
	if (_tmp8_ != NULL) {
		GtkWidget* _tmp9_;
		GtkWidget* _tmp10_;
		GtkWidget* _tmp11_;
		GtkGrid* _tmp12_;
		GtkGrid* _tmp13_;
		GtkWidget* _tmp14_;
		_tmp9_ = warning;
		gtk_widget_set_hexpand (G_TYPE_CHECK_INSTANCE_CAST (_tmp9_, gtk_widget_get_type (), GtkWidget), TRUE);
		_tmp10_ = warning;
		gtk_widget_set_halign (G_TYPE_CHECK_INSTANCE_CAST (_tmp10_, gtk_widget_get_type (), GtkWidget), GTK_ALIGN_CENTER);
		_tmp11_ = warning;
		gtk_widget_show (G_TYPE_CHECK_INSTANCE_CAST (_tmp11_, gtk_widget_get_type (), GtkWidget));
		_tmp12_ = self->priv->grid;
		gtk_grid_set_row_spacing (_tmp12_, 4);
		_tmp13_ = self->priv->grid;
		_tmp14_ = warning;
		gtk_grid_attach (_tmp13_, G_TYPE_CHECK_INSTANCE_CAST (_tmp14_, gtk_widget_get_type (), GtkWidget), 0, 1, 2, 1);
	}
	return self;
}


PropertyRow* property_row_new_from_widgets (const gchar* property_name, GtkWidget* widget, GtkWidget* warning) {
	return property_row_construct_from_widgets (TYPE_PROPERTY_ROW, property_name, widget, warning);
}


gchar* property_row_get_copy_text (PropertyRow* self) {
	gchar* result = NULL;
	GtkWidget* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->value_widget;
	if (_tmp0_ != NULL) {
		GtkWidget* _tmp1_;
		const gchar* _tmp2_;
		gchar* _tmp3_;
		_tmp1_ = self->priv->value_widget;
		_tmp2_ = gtk_label_get_label (G_TYPE_CHECK_INSTANCE_CAST (G_TYPE_CHECK_INSTANCE_CAST (_tmp1_, gtk_widget_get_type (), GtkWidget), gtk_label_get_type (), GtkLabel));
		_tmp3_ = g_strdup (_tmp2_);
		result = _tmp3_;
		return result;
	} else {
		result = NULL;
		return result;
	}
}


PropertyRow* property_row_construct (GType object_type) {
	PropertyRow * self = NULL;
	self = (PropertyRow*) g_object_new (object_type, NULL);
	return self;
}


PropertyRow* property_row_new (void) {
	return property_row_construct (TYPE_PROPERTY_ROW);
}


static void property_row_class_init (PropertyRowClass * klass) {
	gint PropertyRow_private_offset;
	property_row_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (PropertyRowPrivate));
	G_OBJECT_CLASS (klass)->finalize = property_row_finalize;
	PropertyRow_private_offset = g_type_class_get_instance_private_offset (klass);
	gtk_widget_class_set_template_from_resource (GTK_WIDGET_CLASS (klass), "/ca/desrt/dconf-editor/ui/property-row.ui");
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "grid", FALSE, PropertyRow_private_offset + G_STRUCT_OFFSET (PropertyRowPrivate, grid));
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "name_label", FALSE, PropertyRow_private_offset + G_STRUCT_OFFSET (PropertyRowPrivate, name_label));
}


static void property_row_instance_init (PropertyRow * self) {
	self->priv = PROPERTY_ROW_GET_PRIVATE (self);
	self->priv->value_widget = NULL;
	gtk_widget_init_template (GTK_WIDGET (self));
}


static void property_row_finalize (GObject * obj) {
	PropertyRow * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_PROPERTY_ROW, PropertyRow);
	_g_object_unref0 (self->priv->grid);
	_g_object_unref0 (self->priv->name_label);
	_g_object_unref0 (self->priv->value_widget);
	G_OBJECT_CLASS (property_row_parent_class)->finalize (obj);
}


GType property_row_get_type (void) {
	static volatile gsize property_row_type_id__volatile = 0;
	if (g_once_init_enter (&property_row_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (PropertyRowClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) property_row_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PropertyRow), 0, (GInstanceInitFunc) property_row_instance_init, NULL };
		GType property_row_type_id;
		property_row_type_id = g_type_register_static (gtk_list_box_row_get_type (), "PropertyRow", &g_define_type_info, 0);
		g_once_init_leave (&property_row_type_id__volatile, property_row_type_id);
	}
	return property_row_type_id__volatile;
}



